//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                                         
/////////////               overarching clone
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION clone_item
    INT_VAR allow_missing=0
    STR_VAR
           item=""
           edits=""
           editstring=""
    BEGIN
         LAUNCH_ACTION_FUNCTION clone_template
                  STR_VAR file_list= ~%item%~
                          file_ext=~ITM~
                          edits
                          editstring
                          allow_missing

         END
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               overarching edit
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION edit_item
    INT_VAR
           silent=0
           allow_missing=0
           tv=0
    STR_VAR
           item=""
           edits=""
           editstring=""
           location=""
           locbase=""
           locabs=""
    BEGIN
         LAUNCH_ACTION_FUNCTION edit_template
                  STR_VAR file_list= ~%item%~
                          file_ext=~ITM~
                          edits editstring allow_missing
                          tv silent location locbase locabs

         END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               overarching install
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION install_item
    INT_VAR allow_missing=0
            tv=0
    STR_VAR
           item=""
           edits=""
           editstring=""
           location=""
           locbase=""
    BEGIN
         LAUNCH_ACTION_FUNCTION install_template
                  STR_VAR file_list= ~%item%~
                          file_ext=~ITM~
                          edits editstring allow_missing
                          tv silent location locbase

         END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               overarching regexp
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION edit_all_items
    STR_VAR
           edits=""
           editstring=""
    BEGIN
         LAUNCH_ACTION_FUNCTION regexp_template
                   STR_VAR       file_ext=~ITM~
                          edits= ~%edits%~
                          editstring= ~%editstring%~
                          tv=1
         END
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               overarching make
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION make_item
    STR_VAR
           item=""
           edits=""
           editstring=""
    BEGIN
         LAUNCH_ACTION_FUNCTION make_template
                  STR_VAR file_list= ~%item%~
                          file_ext=~ITM~
                          edits= ~%edits%~
                          editstring= ~%editstring%~
                          build_before= ITM_build
                          build_after = ITM_postbuild
         END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               offsets
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

<<<<<<<< item_offsets.2da
TYPE       offset_loc      offset_length       entrynum_loc  entrynum_length   entry_length
ability          0x64            4                   0x68          2                 0x38
effect           0x6a            4                   -1            0                 0x30
>>>>>>>>
OUTER_SPRINT ~offset_readin_lookup_2da~ ~item_offsets~
OUTER_SPRINT ~offset_readin_file_ext~ ~ITM~
LAUNCH_ACTION_MACRO read_in_offsets

OUTER_SPRINT has_secondaries_ITM_ability ""


OUTER_SPRINT $ITM_virtual_type_parent(effect) ability
OUTER_SPRINT $ITM_virtual_type_child(effect) effect
OUTER_SET $ITM_virtual_type_index("effect")=0
OUTER_SET $lookup_ITM_ability_effect_ind_loc(0)=0x20
OUTER_SET $lookup_ITM_ability_effect_ind_length(0)=2
OUTER_SET $lookup_ITM_ability_effect_num_loc(0)=0x1e
OUTER_SET $lookup_ITM_ability_effect_num_length(0)=2

OUTER_SPRINT $ITM_effect_secondaries_follow(ability) effect_global


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               simple data-field edits
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ACTION_DEFINE_ASSOCIATIVE_ARRAY item_fields BEGIN
   name1_string => ~0x8,LONG~
   name2_string => ~0xc,LONG~
   enchantment => ~0x60,LONG~
   category => ~0x1c,SHORT~
   inventory =>~0x22,ASCII2~
   price => ~0x34,LONG~
   max_in_stack =>~0x38,SHORT~
   icon => ~0x3a,ASCII~
   icon_ground =>~0x44,ASCII~
   icon_carried=>~0x58,ASCII~
   minimum_strength=>~0x26,SHORT~
   lore=> ~0x42,SHORT~
   weight=>~0x4c,LONG~
   description1_string => ~0x50,LONG~
   description2_string => ~0x54,LONG~
   num_abils=> ~0x68,SHORT~
   proficiency_code => ~0x31,BYTE~
END

LAUNCH_ACTION_FUNCTION build_simple_data_field_editors STR_VAR lookup_table=item_fields function_prefix=ITM END

ACTION_DEFINE_ASSOCIATIVE_ARRAY item_ability_fields BEGIN
   ability_type => ~0x0,BYTE~
   ability_icon_loc => ~0x2,BYTE~
   ability_icon => ~0x4,ASCII~
   ability_target=>~0xc,BYTE~
   ability_target_count=>~0xd,BYTE~
   ability_range=>~0xe,SHORT~
   launcher_required=>~0x10,SHORT~
   speed=> ~0x12,SHORT~
   to_hit => ~0x14,SHORT~
   ability_dicesize=>~0x16,BYTE~
   ability_school=>~0x17,BYTE~
   ability_secondary=>~0x19,BYTE~
   ability_numdice=>~0x18,BYTE~
   ability_dicenum=>~0x18,BYTE~
   damage_bonus=>~0x1a,SHORT~
   damage_type=>~0x1c,SHORT~
   effect_num=>~0x1e,SHORT~
   effect_offset=>~0x20,SHORT~
   number_charges => ~0x22,SHORT~
   when_drained => ~0x24,BYTE~
   projectile => ~0x2a,SHORT~
   overhand=>~0x2c,SHORT~
   backhand=>~0x2e,SHORT~
   thrust=>~0x30,SHORT~
   is_arrow=>~0x32,SHORT~
   is_bolt=>~0x34,SHORT~
   is_missile=>~0x36,SHORT~
END

LAUNCH_ACTION_FUNCTION build_simple_data_field_editors STR_VAR offset_base=~offset_base~ lookup_table=item_ability_fields function_prefix=ITM END


ACTION_DEFINE_ASSOCIATIVE_ARRAY eff_fields BEGIN
   opcode=>~0,SHORT~
   target=>~0x2,BYTE~
   power=>~0x3,BYTE~
   parameter1=>~0x4,LONG~
   parameter2=>~0x8,LONG~
   parameter2a=>~0x8,SHORT~
   parameter2b=>~0xa,SHORT~
   timing=>~0xc,BYTE~
   resist_dispel=>~0xd,BYTE~
   dispel=>~0xd,BYTE~
   duration=>~0xe,LONG~
   probability1=>~0x12,BYTE~
   probability2=>~0x13,BYTE~
   resource=>~0x14,ASCII~
   dicenum=> ~0x1c,LONG~
   dicesize=> ~0x20,LONG~
   save_bonus=>~0x28,LONG~
   mode=>~0x2c,LONG~
END

LAUNCH_ACTION_FUNCTION build_simple_data_field_editors STR_VAR lookup_table=eff_fields offset_base=~offset_base~ function_prefix=ITM secondary="yes" END

ACTION_DEFINE_ASSOCIATIVE_ARRAY itm_bit_fields BEGIN
      unsellable => ~0x18,0~
      twohanded => ~0x18,1~
      droppable => ~0x18,2~
      displayable => ~0x18,3~
      cursed => ~0x18,4~
      not_copyable => ~0x18,5~
      magical => ~0x18,6~
      bow => ~0x18,7~
      silver => ~0x19,0~
      cold_iron => ~0x19,1~
      stolen => ~0x19,2~
      conversable => ~0x19,3~
      forbid_offhand => ~0x19,5~
      unusable_chaotic => ~0x1e,0~
      unusable_evil => ~0x1e,1~
      unusable_good => ~0x1e,2~
      unusable_GEneutral => ~0x1e,3~
      unusable_lawful => ~0x1e,4~
      unusable_LCneutral => ~0x1e,5~
      unusable_chaotic_priest => ~0x1e,0~
      unusable_evil_priest => ~0x1e,1~
      unusable_good_priest => ~0x1e,2~
      unusable_GEneutral_priest => ~0x1e,3~
      unusable_lawful_priest => ~0x1e,4~
      unusable_LCneutral_priest => ~0x1e,5~
      unusable_bard => ~0x1e,6~
      unusable_cleric => ~0x1e,7~
      unusable_cleric_mage => ~0x1f,0~
      unusable_cleric_thief  => ~0x1f,1~
      unusable_cleric_ranger => ~0x1f,2~
      unusable_fighter => ~0x1f,3~
      unusable_fighter_druid => ~0x1f,4~
      unusable_fighter_mage => ~0x1f,5~
      unusable_fighter_cleric => ~0x1f,6~
      unusable_fighter_mage_cleric => ~0x1f,7~
      unusable_fighter_mage_thief => ~0x20,0~
      unusable_fighter_thief => ~0x20,1~
      unusable_mage => ~0x20,2~
      unusable_mage_thief => ~0x20,3~
      unusable_paladin => ~0x20,4~
      unusable_ranger => ~0x20,5~
      unusable_thief => ~0x20,6~
      unusable_elf => ~0x20,7~
      unusable_dwarf => ~0x21,0~
      unusable_half_elf => ~0x21,1~
      unusable_halfling => ~0x21,2~
      unusable_human => ~0x21,3~
      unusable_gnome => ~0x21,4~
      unusable_monk => ~0x21,5~
      unusable_druid => ~0x21,6~
      unusable_half_orc => ~0x21,7~
      unusable_cleric_of_talos=>~0x29,0~
      unusable_cleric_of_helm=>~0x29,1~
      unusable_cleric_of_lathander=>~0x29,2~
      unusable_totemic_druid=>~0x29,3~
      unusable_shapeshifter=>~0x29,4~
      unusable_avenger=>~0x29,5~
      unusable_barbarian=>~0x29,6~
      unusable_wild_mage=>~0x29,7~
      unusable_stalker=>~0x2b,0~
      unusable_beastmaster=>~0x2b,1~
      unusable_assassin=>~0x2b,2~
      unusable_bounty_hunter=>~0x2b,3~
      unusable_swashbuckler=>~0x2b,4~
      unusable_blade=>~0x2b,5~
      unusable_jester=>~0x2b,6~
      unusable_skald=>~0x2b,7~
      unusable_diviner=>~0x2d,0~
      unusable_enchanter=>~0x2d,1~
      unusable_illusionist=>~0x2d,2~
      unusable_invoker=>~0x2d,3~
      unusable_necromancer=>~0x2d,4~
      unusable_transmuter=>~0x2d,5~
      unusable_no_kit=>~0x2d,6~
      unusable_archer=>~0x2d,7~
      unusable_berserker=>~0x2f,0~
      unusable_wizard_slayer=>~0x2f,1~
      unusable_kensai=>~0x2f,2~
      unusable_cavalier=>~0x2f,3~
      unusable_inquisitor=>~0x2f,4~
      unusable_undead_hunter=>~0x2f,5~
      unusable_abjurer=>~0x2f,6~
      unusable_conjurer=>~0x2f,7~
END

LAF build_flag_data_field_editors STR_VAR lookup_table=itm_bit_fields function_prefix=ITM END

ACTION_DEFINE_ASSOCIATIVE_ARRAY abil_bit_fields BEGIN
      strength_bonus=>~0x26,0~
      breakable=>~0x26,1~
      damage_only=>~0x26,2~
      to_hit_only=>~0x26,3~
      breaks_sanctuary=>~0x27,1~
      hostile=>~0x27,2~
      recharges_on_rest=>~0x27,3~
END
LAF build_flag_data_field_editors STR_VAR lookup_table=abil_bit_fields offset_base=~offset_base~ function_prefix=ITM END


ACTION_DEFINE_ASSOCIATIVE_ARRAY eff_bit_fields BEGIN
      save_vs_spell => ~0x24,0~
      save_vs_breath => ~0x24,1~
      save_vs_death => ~0x24,2~
      save_vs_poison => ~0x24,2~
      save_vs_wands => ~0x24,3~
      save_vs_petrification => ~0x24,4~
      save_vs_polymorph => ~0x24,4~
      bypass_mirror_image =>~0x27,0~
END

LAF build_flag_data_field_editors STR_VAR lookup_table=eff_bit_fields offset_base=~offset_base~ function_prefix=ITM  secondary="yes" END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               data-field edits involving lookup
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ACTION_DEFINE_ASSOCIATIVE_ARRAY ~itm_ids_fields~ BEGIN
   proficiency => ~0x31,BYTE,STATS~
END

LAUNCH_ACTION_FUNCTION build_IDS_data_field_editors STR_VAR lookup_table=itm_ids_fields function_prefix=ITM END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               delete opcodes
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION ~ITM_delete_opcodes~
             STR_VAR arguments=""
BEGIN
     PATCH_IF ~%arguments%~ STRING_COMPARE ~~ BEGIN
        LPF return_first_entry STR_VAR list= ~%arguments%~ RET arguments=list opcode_to_delete=entry END
        PATCH_MATCH ~%opcode_to_delete%~ WITH
        all BEGIN
             LPF DELETE_ITEM_EFFECT INT_VAR opcode_to_delete=~-1~ END
             LPF DELETE_ITEM_EQEFFECT INT_VAR opcode_to_delete=~-1~ END
        END
        equipped BEGIN
             LPF DELETE_ITEM_EQEFFECT INT_VAR opcode_to_delete=~-1~ END
        END
        ability BEGIN
             LPF DELETE_ITEM_EFFECT INT_VAR opcode_to_delete=~-1~ END
        END
        DEFAULT
          LPF DELETE_ITEM_EFFECT INT_VAR opcode_to_delete END
          LPF DELETE_ITEM_EQEFFECT INT_VAR opcode_to_delete END
          LPF ITM_delete_opcodes STR_VAR arguments END
        END
     END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("ITM_delete_opcodes") ""

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               give immunity to opcodes
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION ITM_immunity_to_opcode
       STR_VAR arguments=""
BEGIN
       PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
          LPF return_first_entry STR_VAR list=~%arguments%~ RET entry=entry arguments=list END
         LPF delete_entry STR_VAR type=effect_global arguments=~opcode=101 and parameter2=%entry%~ file_ext=ITM END
         LPF add_entry_inline STR_VAR arguments =~opcode=>101 parameter2=>%entry%~ type=effect_global file_ext=ITM END
          LPF ITM_immunity_to_opcode STR_VAR arguments END
       END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("ITM_immunity_to_opcode") ""

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              give immunity to a spell (opcode 206)
/////////////
/////////////              if we use "arguments" assume it's a string of entries
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION ITM_immunity_to_spell
       STR_VAR spellname=""
               spellcode=""
               arguments=""
BEGIN
       PATCH_IF ~%spellname%~ STRING_COMPARE_CASE ~~ BEGIN
              LPF deabbreviate_spellname STR_VAR input=  ~%spellname%~ RET spellname END
              PATCH_IF VARIABLE_IS_SET "%spellname%" BEGIN
                  SPRINT spellcode EVALUATE_BUFFER ~%%spellname%%~
              END ELSE BEGIN
                 SPRINT spellcode "%spellname%"
                 LPF warning STR_VAR warning="Spell %spellname% does not appear to exist" END
              END
       END
       PATCH_IF ~%spellcode%~ STRING_COMPARE_CASE ~~ BEGIN
         LPF add_entry_inline STR_VAR arguments =~opcode=>206 resource=>%spellcode%~ type=effect_global file_ext=ITM END
       END
       PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
          LPF return_first_entry STR_VAR list= ~%arguments%~ RET spell=entry arguments=list END
          INNER_ACTION BEGIN
                  ACTION_IF FILE_EXISTS_IN_GAME ~%spell%.spl~ BEGIN
                     OUTER_SPRINT spellcode ~%spell%~
                     OUTER_SPRINT spellname ~~
                  END ELSE BEGIN
                     OUTER_SPRINT spellname ~%spell%~
                     OUTER_SPRINT spellcode ~~
                  END
          END
          LPF ITM_immunity_to_spell STR_VAR arguments spellname spellcode END
       END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("ITM_immunity_to_spell") ""


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              take an item, and transfer all effects of a given ability onto a new spell
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION copy_item_to_spell
         INT_VAR abil_ind=0
         STR_VAR item=""
                 spell=""
BEGIN
         // make a new spell
         LAF make_spell STR_VAR spell= ~%spell%~ END
         // add the labelled ability of the item, and the effects, to the spell
         COPY_EXISTING ~%item%.itm~ ~override~
           READ_ASCII ((LONG_AT 0x64) + 0x38 * abil_ind) ability (0x38)
           SET offset=LONG_AT 0x64
           READ_SHORT 0x72 type
           INNER_PATCH_SAVE ability ~%ability%~ BEGIN
             WRITE_BYTE 0x2 4 // innate slots
             WRITE_BYTE 0x1 0
             WRITE_SHORT 0x10 1 // min level
             DELETE_BYTES 0x26 0x4
             DELETE_BYTES 0x28 0xc
             READ_SHORT 0x1e eff_num
             READ_SHORT 0x20 eff_ind
             WRITE_SHORT 0x20 0
             READ_SHORT 0x26 proj
             PATCH_IF proj>1 BEGIN
                WRITE_BYTE 0x0 2
             END ELSE BEGIN
                WRITE_BYTE 0x0 1
             END
           END
           SET eff_length=0x30*eff_num
           READ_ASCII ((LONG_AT 0x6a) + 0x30*eff_ind) effects (eff_length)
           INNER_ACTION BEGIN
                COPY_EXISTING ~%spell%.spl~ ~override~
                     INSERT_BYTES (LONG_AT 0x64) 0x28
                     WRITE_ASCIIE (LONG_AT 0x64) ~%ability%~
                     WRITE_SHORT 0x68 1
                     WRITE_LONG 0x6a ((LONG_AT 0x6a) + 0x28)
                     INSERT_BYTES (LONG_AT 0x6a) ~eff_length~
                     WRITE_ASCIIE (LONG_AT 0x6a) ~%effects%~
                BUT_ONLY
           END
         BUT_ONLY
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              externalise an item's global effects to a spell (so the spell applies, permanently, all the item's effects) leaving the item itself unchanged
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION copy_item_effects_to_spell
    STR_VAR item=""
            spell=""
BEGIN
         // make a new spell
         LAF make_spell STR_VAR spell END
         COPY_EXISTING "%item%.itm" "%workspace%"
             READ_SHORT 0x70 num_eff
             READ_ASCII (LONG_AT 0x6a + (SHORT_AT 0x6e)*0x30) eff_array (num_eff*0x30) // read in whole effect block
         BUT_ONLY
         COPY_EXISTING "%spell%.spl" override
                 INNER_PATCH_SAVE ability "" BEGIN
                    INSERT_BYTES 0x0 0x28
                    WRITE_SHORT 0x0 1 // type: melee
                    WRITE_SHORT 0x2 4 // slot:innate
                    WRITE_ASCII 0x4 "noicon"
                    WRITE_BYTE 0xc 5 // target:caster
                    WRITE_SHORT 0xe 1 // range
                    WRITE_SHORT 0x10 1 // min level
                    WRITE_SHORT 0x16 6 // dice size - just in case
                    WRITE_SHORT 0x1c 1 // piercing type - just in case
                    WRITE_SHORT 0x1e "%num_eff%"
                    WRITE_SHORT 0x22 1 // num charges
                    WRITE_SHORT 0x24 1 // unknown
                    WRITE_SHORT 0x26 1 // projectile NONE

                 END
                 WRITE_SHORT 0x68 1
                 INSERT_BYTES 0x72 0x28
                 WRITE_ASCII 0x72 "%ability%"
                 WRITE_LONG 0x6a 0x72+0x28
                 INSERT_BYTES (0x72+0x28) (0x30*num_eff)
                 WRITE_ASCII (0x72+0x28) "%eff_array%"
         BUT_ONLY
         LAF edit_spell STR_VAR spell editstring="patch_effect_inline=>~timing=>9~" END

END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              externalise an item's ability to a spell (so all the ability does is cast the spell)
/////////////              The item has the same name as the spell unless you specify another explicitly
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION externalise_item_ability
         INT_VAR abil_ind=0
         STR_VAR item=""
                 spell=""
BEGIN
   // find the name for the spell
   ACTION_IF "%spell%" STRING_EQUAL "" BEGIN
      ACTION_IF !FILE_EXISTS_IN_GAME "%item%.spl" BEGIN
         OUTER_SPRINT spell "%item%"
      END ELSE BEGIN
         FAIL "No explicit choice of spell for externalised %item%.itm, and %item%.spl is not available"
      END
   END
   // make the spell
   LAF copy_item_to_spell INT_VAR abil_ind STR_VAR item spell END
   // edit the item

   ACTION_CLEAR_ARRAY patch_data
   ACTION_DEFINE_ASSOCIATIVE_ARRAY patch_data BEGIN
      delete_effect=>"parent_index=%abil_ind%"
      add_effect_inline=>"match=>~parent_index=%abil_ind%~ opcode=>146 parameter2=>1 resource=>%spell% target=>2 timing=>1"
   END
   LAF edit_item STR_VAR item edits=patch_data END
END




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////             append the description
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION ITM_append_description
   STR_VAR arguments=""
BEGIN
   LPF patch_text_entry STR_VAR function=append_string_nospace loc=0x54 arguments= ~%arguments%~ END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("ITM_append_description") ""

DEFINE_PATCH_FUNCTION ITM_append_description_newline
   STR_VAR arguments=""
BEGIN
   LPF patch_text_entry STR_VAR function=append_string_nospace loc=0x54 arguments= ~%WNL%%arguments%~ END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("ITM_append_description_newline") ""

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////             substitute the description
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION ITM_substitute_description
   STR_VAR arguments=""
BEGIN
   LPF patch_text_entry STR_VAR function=substitute_string loc=0x54 arguments= ~%arguments%~ END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("ITM_substitute_description") ""

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////             set the description
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION ITM_set_description
   STR_VAR arguments=""
BEGIN
   LPF patch_text_entry STR_VAR function=set_string loc=0x54 arguments END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("ITM_set_description") ""

DEFINE_PATCH_FUNCTION ITM_set_unidentified_description
   STR_VAR arguments=""
BEGIN
   SAY 0x50 (AT "%arguments%")
   LPF patch_text_entry STR_VAR function=set_string loc=0x50 arguments END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("ITM_set_unidentified_description") ""


DEFINE_PATCH_FUNCTION ITM_say_description
   STR_VAR arguments=""
BEGIN
   LPF item_useability_string INT_VAR tra_ref=arguments RET desc END
   LPF patch_text_entry STR_VAR function=set_string loc=0x54 arguments="%desc%" END
END

DEFINE_PATCH_FUNCTION ITM_say_unidentified_description
   STR_VAR arguments=""
BEGIN
   LPF item_useability_string INT_VAR tra_ref=arguments RET desc END
   LPF patch_text_entry STR_VAR function=set_string loc=0x50 arguments="%desc%" END
END

DEFINE_PATCH_FUNCTION ITM_set_both_descriptions
   STR_VAR arguments=""
BEGIN
   LPF ITM_set_description STR_VAR arguments END
   LPF ITM_set_unidentified_description STR_VAR arguments END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("ITM_set_both_descriptions") ""

DEFINE_PATCH_FUNCTION ITM_say_both_descriptions
   STR_VAR arguments=""
BEGIN
   LPF ITM_say_description STR_VAR arguments END
   LPF ITM_say_unidentified_description STR_VAR arguments END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////             get the name
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION ITM_identified_name
       RET value
BEGIN
       READ_STRREF 0xc value
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////             set the name
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION ITM_set_name
   STR_VAR arguments=""
BEGIN
   LPF patch_text_entry STR_VAR function=set_string loc=0xc arguments= ~%arguments%~ END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("ITM_set_name") ""

DEFINE_PATCH_FUNCTION ITM_set_name_evaluate
   STR_VAR arguments=""
BEGIN
   LPF patch_text_entry STR_VAR function=set_string loc=0xc arguments= ~%arguments%~ END
END

DEFINE_PATCH_FUNCTION ITM_set_unidentified_name
   STR_VAR arguments=""
BEGIN
   LPF patch_text_entry STR_VAR function=set_string loc=0x8 arguments= ~%arguments%~ END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("ITM_set_unidentified_name") ""

DEFINE_PATCH_FUNCTION ITM_say_name
   STR_VAR arguments=""
BEGIN
   LPF say_this_here INT_VAR offset=0xc say= ~%arguments%~ END
END

DEFINE_PATCH_FUNCTION ITM_say_unidentified_name
   STR_VAR arguments=""
BEGIN
   LPF say_this_here INT_VAR offset=0x8 say= ~%arguments%~ END
END


DEFINE_PATCH_FUNCTION ITM_set_both_names
   STR_VAR arguments=""
BEGIN
   LPF ITM_set_name STR_VAR arguments END
   LPF ITM_set_unidentified_name STR_VAR arguments END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("ITM_set_both_names") ""

DEFINE_PATCH_FUNCTION ITM_say_both_names
   STR_VAR arguments=""
BEGIN
   LPF ITM_say_name STR_VAR arguments END
   LPF ITM_say_unidentified_name STR_VAR arguments END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////             build
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION ITM_build
BEGIN
      ///// basic structure
   DELETE_BYTES 0x0 BUFFER_LENGTH
   INSERT_BYTES 0x0 0x72
   // sig
   WRITE_ASCII 0x0 ~ITM V1  ~
  // name
   WRITE_LONG 0x8 ~-1~
   WRITE_LONG 0xc ~-1~
   // max in stack
   WRITE_SHORT 0x38 1
  // description
   WRITE_LONG 0x50 ~-1~
   WRITE_LONG 0x54 ~-1~
   //offsets
   WRITE_LONG 0x64 0x72
   WRITE_LONG 0x6a 0x72
END

DEFINE_PATCH_FUNCTION ITM_postbuild BEGIN
   // sort out relevant proficiency
   SET prof=0
   SPRINT inv ""
   READ_SHORT 0x1c category
   PATCH_MATCH category WITH
   25 BEGIN // axes
      SPRINT inv AX
   END
   28 BEGIN // handheld weapons
      SPRINT inv H6
   END
   69 BEGIN // bastard swords
     SPRINT inv S1
     SET prof=89
   END
   15 BEGIN // bows
     SPRINT inv BW
     SET prof=104
   END
   44 BEGIN // clubs
     SPRINT inv CL
     SET prof=115
   END
   27 BEGIN // crossbows
     SPRINT inv CB
     SET prof=103
   END
   16 BEGIN // daggers
     SPRINT inv DD
     SET prof=96
   END
   24 BEGIN // darts
     SET prof=106
   END
   23 BEGIN // flails
      SPRINT inv FL
      SET prof=100
   END
   57 BEGIN // greatswords
      SPRINT inv S2
      SET prof=93
   END
   30 BEGIN // halberds
      SPRINT inv HB
      SET prof=99
   END
   21 BEGIN // hammers
      SPRINT inv WH
      SET prof=97
   END
   20 BEGIN // longswords
      SPRINT inv S1
      SET prof=90
   END
   17 BEGIN // maces
      SPRINT inv MC
      SET prof=101
   END
   22 BEGIN // morning stars
      SPRINT inv MS
      SET prof=100
   END
   26 BEGIN // quarterstaffs
      SPRINT inv QS
      SET prof=102
   END
   12 BEGIN // shields
       SPRINT inv D2
   END
   19 BEGIN // shortswords
       SPRINT inv SS
       SET prof=91
   END
   18 BEGIN // slings
       SPRINT inv SL
       SET prof=107
   END
   29 BEGIN // spears
      SPRINT inv SP
      SET prof=98
   END
   DEFAULT
   END
   PATCH_IF (prof>0) BEGIN
       LPF ITM_read_proficiency_code RET value=value END
       PATCH_IF value=0 BEGIN
          LPF ITM_proficiency_code STR_VAR arguments= ~%prof%~ END
       END
   END
   PATCH_IF (~%inv%~ STRING_COMPARE ~~) BEGIN
      LPF ITM_read_inventory RET value=value END
      PATCH_IF ~%value%~ STRING_EQUAL_CASE ~~ BEGIN
         LPF ITM_inventory STR_VAR arguments= ~%inv%~ END
      END
   END

END

/////////////////////////////////////////////////////////////////////////////////////////////
///        logs the name of the item
/////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION ITM_log_me STR_VAR filename="" arguments="" BEGIN
   LPF log_this STR_VAR file= ~%arguments%~ input= ~%filename%~ repeat=no END
END

/////////////////////////////////////////////////////////////////////////////////////////////
///      code to make an item description string according to whether EE is installed
/////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION item_useability_string
   INT_VAR tra_ref=0
   RET desc
BEGIN
   SPRINT desc ( AT "%tra_ref%")
   PATCH_IF enhanced_edition BEGIN
       PATCH_IF VARIABLE_IS_SET SFO_unusable_string_tra_ref BEGIN
          SPRINT unusable ( AT "%SFO_unusable_string_tra_ref%")
          INNER_PATCH "%desc%" BEGIN
            SET ind=INDEX_BUFFER (CASE_INSENSITIVE "%unusable%")
            PATCH_IF ind>=0 BEGIN
               READ_ASCII 0x0 desc (ind)
            END
          END
       END
       PATCH_IF VARIABLE_IS_SET SFO_usable_string_tra_ref BEGIN
          SPRINT usable ( AT "%SFO_usable_string_tra_ref%")
          INNER_PATCH "%desc%" BEGIN
            SET ind=INDEX_BUFFER (CASE_INSENSITIVE "%usable%")
            PATCH_IF ind>=0 BEGIN
               READ_ASCII 0x0 desc (ind)
            END
          END
       END
   END
END


////////////////////////////////////////////////////////////////////////////////////////
/// Armor-type-finding function
///
/// use example: LAF armor_type STR_VAR item=chan01 RET success type END
///
/// success=1 if we find the armor type, 0 if we don't
/// type is one of:   file_does_not_exist, not_armor, robes, leather, studded_leather, hide, chain, splint, plate, full_plate, scale, unknown
///
/// if we can't work it out, but it is armor, we try to guess (but still set success=0)
////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION armor_type
    STR_VAR item=""
    RET type success
BEGIN
   OUTER_SET success=0
   ACTION_IF FILE_EXISTS_IN_GAME "%item%.cre" BEGIN
      COPY_EXISTING "%item%.itm" override
         // start by looking at the category, to confirm it's actually armor
         PATCH_IF !((SHORT_AT 0x1c)=2) BEGIN
              SET success=1
              SPRINT type not_armor
         END
         PATCH_IF !success BEGIN
            // look at the animation type
            READ_SHORT 0x22 anim_type
            PATCH_MATCH "%anim_type%" WITH
                2W 3W 4W BEGIN // robes
                   SET success=1
                   SPRINT type robes
                END
                // end of 2W 3W 4W section
                2A BEGIN // leather armor - could be ordinary,studded,hide
                   LPF read_armor_bonus_by_type RET slashing piercing crushing missile END
                   PATCH_IF (piercing="-2" && missile="-2") BEGIN  // either leather or hide
                         PATCH_IF (SHORT_AT 0x26)=6 BEGIN // if you need strength 6 (rather than 4), it's hide
                            SET success=1
                            SPRINT type hide
                         END ELSE BEGIN
                            SET success=1
                            SPRINT type leather
                         END
                   END ELSE
                   PATCH_IF (slashing=2 && piercing=1 && missile=1) BEGIN // studded leather
                      SET success=1
                      SPRINT type studded_leather
                   END ELSE BEGIN
                      SET success=0
                      SPRINT type leather // guess leather
                   END
                END
                // end of 2A section
                3A BEGIN // chain or splint
                   LPF read_armor_bonus_by_type RET slashing piercing crushing missile END
                   PATCH_IF (slashing=2 && crushing="-2") BEGIN // chain mail
                      SET success=1
                      SPRINT type chain
                   END ELSE
                   PATCH_IF (piercing=1 && missile=1 && crushing=2) BEGIN
                      SET success=1
                      SPRINT type splint
                   END ELSE BEGIN
                      SET success=0
                      SPRINT type chain // guess chain
                   END
                END
                // end of 3A section
                4A BEGIN // plate or full plate
                   LPF read_armor_bonus_by_type RET slashing piercing crushing missile END
                   PATCH_IF (slashing=3 && missile=0 && piercing=0) BEGIN // plate mail
                        SET success=1
                        SPRINT type plate
                   END ELSE
                   PATCH_IF (piercing=3 && missile=3 && slashing=4) BEGIN
                        SET success=1
                        SPRINT type full_plate
                   END ELSE
                   PATCH_IF (slashing=3 && missile=1 && piercing=1) BEGIN // scale male - just a couple of dragon armors
                        SET success=1
                        SPRINT type scale
                   END ELSE BEGIN
                        SET success=0
                        SPRINT type plate // guess plate
                   END
                END
                // end of 4A section
                DEFAULT
                        SET success=0
                        SPRINT type robes // guess robes
            END
         END
       BUT_ONLY
   END ELSE BEGIN
        OUTER_SET success=0
        OUTER_SPRINT type file_does_not_exist
   END
END

////////////////////////////////////////////////////////////////////////////////////////
/// Helper function. Returns the vs-type bonuses for armor
////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION read_armor_bonus_vs_type
    RET slashing piercing crushing missile
BEGIN
   DEFINE_ASSOCIATIVE_ARRAY type_map BEGIN
      1=>crushing
      2=>missile
      4=>piercing
      8=>slashing
   END
   PHP_EACH type_map AS discard=>value BEGIN
      SET "%value%"=0
   END
   GET_OFFSET_ARRAY offsets ITM_V10_GEN_EFFECTS
   PHP_EACH offsets AS discard=>offset BEGIN
        PATCH_IF (SHORT_AT offset)=0 BEGIN // is an AC modification
           READ_LONG (0x8 + offset) type
           PHP_EACH type_map AS key=>value BEGIN
              PATCH_IF type=key BEGIN
                 READ_LONG (0x4 + offset) modifier
                 SET "%value%"=modifier
              END
           END
        END
   END
END

////////////////////////////////////////////////////////////////////////////////////////
/// Return 1 if the item is stackable
////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION ITM_is_stackable
   RET value
BEGIN
   SET value=0
   PATCH_IF (SHORT_AT 0x38>1) BEGIN
      SET value=1
   END 
   PATCH_IF value=0 BEGIN
      GET_OFFSET_ARRAY ab_arr ITM_V10_HEADERS
      PHP_EACH ab_arr AS ind=>ab_off BEGIN
         PATCH_IF (SHORT_AT (0x22 + ab_off) )>1 BEGIN
            SET value=1
         END
      END
   END
END



// Apply CamDawg's immunity arrays

DEFINE_PATCH_FUNCTION ITM_cd_immunity
  STR_VAR
  arguments	= ""
BEGIN
  WHILE "%arguments%" STRING_COMPARE ""
  BEGIN
    LAUNCH_PATCH_FUNCTION return_first_entry
      STR_VAR
      list	= "%arguments%"
      RET
      arguments	= list
      entry
    END

    LAUNCH_PATCH_FUNCTION cd_apply_batch
      STR_VAR
      array_name	= "cd_immunity_%entry%_arrays"
    END
  END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("ITM_cd_immunity") ""


