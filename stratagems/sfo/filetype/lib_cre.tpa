        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               overarching clone
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION clone_creature
    INT_VAR
           allow_missing=0
           tv=0
    STR_VAR
           creature=""
           edits=""
           editstring=""

    BEGIN
         LAUNCH_ACTION_FUNCTION clone_template
                  INT_VAR allow_missing tv
                  STR_VAR file_list= ~%creature%~
                          file_ext=~CRE~
                          edits
                          editstring
         END
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               overarching edit
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION edit_creature
    INT_VAR
           allow_missing=0
           tv=0
    STR_VAR
           creature=""
           file=""
           edits=""
           editstring=""
           location=""
           locbase=""
           locabs=""
    BEGIN
         LAUNCH_ACTION_FUNCTION edit_template
                  INT_VAR allow_missing tv
                  STR_VAR file_list= ~%creature%~
                          file_ext=~CRE~
                          external_file= ~%file%~
                          edits editstring location locbase locabs

         END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               overarching regexp
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION edit_all_creatures
    STR_VAR
           edits=""
           editstring=""
    BEGIN
         LAUNCH_ACTION_FUNCTION regexp_template
                   STR_VAR       file_ext=~CRE~
                          edits
                          editstring
         END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               overarching install
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION install_creature
    INT_VAR
           allow_missing=0
           tv=0
    STR_VAR
           creature=""
           edits=""
           editstring=""
           location=""
           locbase=""
    BEGIN
         LAUNCH_ACTION_FUNCTION install_template
                  INT_VAR allow_missing tv
                  STR_VAR file_list= ~%creature%~
                          file_ext=~CRE~
                          edits editstring allow_missing
                          tv silent location locbase

         END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               overarching make
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION make_creature
    STR_VAR
           creature=""
           edits=""
           editstring=""
    BEGIN
         LAUNCH_ACTION_FUNCTION make_template
                  STR_VAR file_list= ~%creature%~
                          file_ext=~CRE~
                          edits= ~%edits%~
                          editstring= ~%editstring%~
                          build_before= CRE_build
                          build_after = CRE_postbuild
         END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               offsets [negative numbers code a fixed number]
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

<<<<<<<< cre_offsets.2da
TYPE                 offset_loc      offset_length       entrynum_loc  entrynum_length   entry_length
known_spell         0x2a0           4                   0x2a4         4                 0xc
memorization_info    0x2a8           4                   0x2ac         4                 0x10
memorized_spell     0x2b0           4                   0x2b4         4                 0xc
effect              0x2c4           4                   0x2c8         4                 0x108
item_slots           0x2b8           4                  -1             0                 0x2
item                0x2bc           4                   0x2c0         4                 0x14
>>>>>>>>

// leaving effects for now, it depends on cretype
OUTER_SPRINT ~offset_readin_lookup_2da~ ~cre_offsets~
OUTER_SPRINT ~offset_readin_file_ext~ ~CRE~
LAUNCH_ACTION_MACRO read_in_offsets


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               simple data-field edits
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ACTION_DEFINE_ASSOCIATIVE_ARRAY cre_fields BEGIN
   name1_string=> ~0x8,LONG~
   name2_string=> ~0xc,LONG~
   xp_value=> ~0x14,LONG~
   xp_total=> ~0x18,LONG~
   gold=> ~0x1c,LONG~
   color_metal => ~0x2c,BYTE~
   color_minor => ~0x2d,BYTE~
   color_major => ~0x2e,BYTE~
   color_skin => ~0x2f,BYTE~
   color_leather => ~0x30,BYTE~
   color_armor => ~0x31,BYTE~
   color_hair => ~0x32,BYTE~
   hide_in_shadows => ~0x45,BYTE~
   detect_illusions => ~0x64,BYTE~
   set_traps => ~0x65,BYTE~
   lore =>~0x66,BYTE~
   open_locks=>~0x67,BYTE~
   move_silently=>~0x68,BYTE~
   find_traps=>~0x69,BYTE~
   pick_pockets=>~0x6a,BYTE~
   resist_fire =>~0x59,SBYTE~
   resist_cold =>~0x5a,SBYTE~
   resist_electricity =>~0x5b,SBYTE~
   resist_acid =>~0x5c,SBYTE~
   resist_magic =>~0x5d,SBYTE~
   resist_magic_fire =>~0x5e,SBYTE~
   resist_magic_cold =>~0x5f,SBYTE~
   resist_slashing =>~0x60,SBYTE~
   resist_crushing =>~0x61,SBYTE~
   resist_piercing =>~0x62,SBYTE~
   resist_missile =>~0x63,SBYTE~
   level     =>    ~0x234,BYTE~
   level1     =>    ~0x234,BYTE~
   level2    =>    ~0x235,BYTE~
   level3    =>    ~0x236,BYTE~
   str       =>    ~0x238,BYTE~
   str_ex    =>    ~0x239,BYTE~
   int       =>    ~0x23a,BYTE~
   wis       =>    ~0x23b,BYTE~
   dex       =>    ~0x23c,BYTE~
   con       =>    ~0x23d,BYTE~
   cha       =>    ~0x23e,BYTE~
   strength       =>    ~0x238,BYTE~
   strength_ex    =>    ~0x239,BYTE~
   intelligence       =>    ~0x23a,BYTE~
   wisdom       =>    ~0x23b,BYTE~
   dexterity       =>    ~0x23c,BYTE~
   constitution       =>    ~0x23d,BYTE~
   charisma       =>    ~0x23e,BYTE~
   sex            =>     ~0x237,BYTE~
   script_override  =>    ~0x248,ASCII~
   script_class     =>    ~0x250,ASCII~
   script_race      =>    ~0x258,ASCII~
   script_general   =>    ~0x260,ASCII~
   script_default   =>    ~0x268,ASCII~
   specifics        =>    ~0x274,BYTE~
   save_vs_death    =>    ~0x54,SBYTE~
   save_vs_wand    =>    ~0x55,SBYTE~
   save_vs_wands    =>    ~0x55,SBYTE~
   save_vs_poly     =>    ~0x56,SBYTE~
   save_vs_polymorph     =>    ~0x56,SBYTE~
   save_vs_breath   =>    ~0x57,SBYTE~
   save_vs_spell    =>    ~0x58,SBYTE~
   save_vs_spells    =>    ~0x58,SBYTE~
   thac0            =>    ~0x52,SBYTE~
   attacks          =>    ~0x53,BYTE~
   hp_max           =>    ~0x26,SHORT~
   hp_current       =>    ~0x24,SHORT~
   dv               =>    ~0x280,ASCII20~
   dialog           =>    ~0x2cc,ASCII~
   animation_code   =>     ~0x28,SHORT~
   effect_type      =>     ~0x33,BYTE~
   ac_natural       =>     ~0x46,SSHORT~
   ac_effective     =>     ~0x48,SSHORT~
   morale           =>     ~0x23f,BYTE~
   morale_break     =>     ~0x240,BYTE~
   nightmare_mode   =>     ~0x7d,BYTE~
END

LAUNCH_ACTION_FUNCTION build_simple_data_field_editors STR_VAR lookup_table=cre_fields function_prefix=CRE END

ACTION_DEFINE_ASSOCIATIVE_ARRAY cre_rel_fields BEGIN
     item_resource => ~0x0,ASCII~
     item_charges_1 => ~0xa,SHORT~
     item_charges_2 => ~0xc,SHORT~
     item_charges_3 => ~0xe,SHORT~
     spell_resource => ~0x0,ASCII~
     opcode => ~0x8,LONG~
     resource=>~0x28,ASCII~
     target=>~0xc,LONG~
     effect_resource=>~0x28,ASCII~
     timing=>~0x1c,LONG~
     probability1=>~0x24,SHORT~
     probability2=>~0x26,SHORT~
     duration=>~0x20,LONG~
     parameter1 => ~0x14,LONG~
     parameter2 => ~0x18,LONG~
     item_slot => ~0x0,SHORT~
     memorized_spell => ~0x0,ASCII~
     resist_dispel=>~0x54,LONG~
     memorization_level => ~0x0,SHORT~
     number_can_memorize => ~0x2,SHORT~
     number_has_memorized => ~0x4,SHORT~
     memorization_type => ~0x6,SHORT~
     parent_resource_type=>~0x88,LONG~
     parent_resource=>~0x8c,ASCII~
     parent_item_slot=>~0x9c,LONG~
     mode=>~0x40,LONG~
   power => ~0x18,LONG~
END

LAUNCH_ACTION_FUNCTION build_simple_data_field_editors STR_VAR lookup_table=cre_rel_fields offset_base=~offset_base~ function_prefix=CRE END




ACTION_DEFINE_ASSOCIATIVE_ARRAY cre_bit_fields BEGIN
      no_corpse => ~0x10,1~
      permanent_corpse => ~0x10,2~
      original_class_fighter=>"0x10,3"
      original_class_mage=>"0x10,4"
      original_class_cleric=>"0x10,5"
      original_class_thief=>"0x10,6"
      original_class_druid=>"0x10,7"
      original_class_ranger=>"0x11,0"
      ignore_nightmare_mode=>"0x12,6"
      state_sleeping => ~0x20,0~
      state_berserk => ~0x20,1~
      state_panic  => ~0x20,2~
      state_stunned  => ~0x20,3~
      state_invisible  => ~0x20,4~
      state_helpless  => ~0x20,5~
      state_frozen_death  => ~0x20,6~
      state_stone_death  => ~0x20,7~
      state_exploding_death => ~0x21,0~
      state_flame_death =>~0x21,1~
      state_acid_death=>~0x21,2~
      state_dead=>~0x21,3~
      state_silenced=>~0x21,4~
      state_charmed=>~0x21,5~
      state_poisoned=>~0x21,6~
      state_hasted=>~0x21,7~
      state_slowed=>~0x22,0~
      state_infravision=>~0x22,1~
      state_blind=>~0x22,2~
      state_diseased=>~0x22,3~
      state_feebleminded=>~0x22,4~
      state_nondetection=>~0x22,5~
      state_improved_invisibility=>~0x22,6~
      state_bless=>~0x22,7~
      state_chant=>~0x23,0~
      state_drawuponholymight=>~0x23,1~
      state_luck=>~0x23,2~
      state_aid=>~0x23,3~
      state_chantbad=>~0x23,4~
      state_blur=>~0x23,5~
      state_mirrorimage=>~0x23,6~
      state_confused=>~0x23,7~
      state_hidden => ~0x22,3~
END

LAF build_flag_data_field_editors STR_VAR lookup_table=cre_bit_fields function_prefix=CRE END


ACTION_DEFINE_ASSOCIATIVE_ARRAY cre_rel_bit_fields BEGIN
      unstealable => ~0x10,1~
      undroppable => ~0x10,3~
END


LAF build_flag_data_field_editors STR_VAR lookup_table=cre_rel_bit_fields offset_base="offset_base" function_prefix=CRE END






//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               composite data-field edits
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// current and max hp

DEFINE_PATCH_FUNCTION CRE_hitpoints STR_VAR arguments="" BEGIN
   LAUNCH_PATCH_FUNCTION CRE_hp_max STR_VAR arguments= ~%arguments%~ END
   LAUNCH_PATCH_FUNCTION CRE_hp_current STR_VAR arguments= ~%arguments%~ END
END


DEFINE_PATCH_FUNCTION CRE_hitpointsGT STR_VAR arguments="" BEGIN
   LAUNCH_PATCH_FUNCTION CRE_hp_maxGT STR_VAR arguments= ~%arguments%~ END
   LAUNCH_PATCH_FUNCTION CRE_hp_currentGT STR_VAR arguments= ~%arguments%~ END
END
// all three levels

DEFINE_PATCH_FUNCTION CRE_level_all STR_VAR arguments="" BEGIN
   LPF CRE_level STR_VAR arguments END
   LPF CRE_level2 STR_VAR arguments END
   LPF CRE_level3 STR_VAR arguments END
END

// both ACs

DEFINE_PATCH_FUNCTION CRE_ac STR_VAR arguments="" BEGIN
   LPF CRE_ac_natural STR_VAR arguments END
   LPF CRE_ac_effective STR_VAR arguments END
END

// all saving throws

DEFINE_PATCH_FUNCTION CRE_saves STR_VAR arguments="" BEGIN
   INNER_ACTION BEGIN
           LAUNCH_ACTION_FUNCTION decompose_CSV
                     STR_VAR input= ~%arguments%~
                     RET save_vs_death=argument_0
                         save_vs_wands=argument_1
                         save_vs_poly=argument_2
                         save_vs_breath=argument_3
                         save_vs_spell=argument_4
           END
   END
   PATCH_FOR_EACH save IN death wands poly breath spell BEGIN
      SPRINT ~string~ ~LAUNCH_PATCH_FUNCTION CRE_save_vs_%save% STR_VAR arguments= "%percentage%save_vs_%save%%percentage%" END~
      LAUNCH_PATCH_FUNCTION patch_reinclude_this STR_VAR input= ~%string%~ END
   END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_saves") ""

// original class

DEFINE_PATCH_FUNCTION CRE_original_class STR_VAR arguments="" BEGIN
   PATCH_MATCH "%arguments%" WITH
   NO_CHANGE BEGIN END
   FIGHTER MAGE CLERIC THIEF DRUID RANGER NONE BEGIN
    TO_LOWER arguments
    PATCH_FOR_EACH class IN
    fighter mage cleric thief druid ranger BEGIN
      PATCH_IF "%class%" STRING_EQUAL "%arguments%" BEGIN
         LPF "CRE_original_class_%class%" INT_VAR arguments=1 END
      END ELSE BEGIN
         LPF "CRE_original_class_%class%" INT_VAR arguments=0 END
      END
    END
   END
   DEFAULT
      PATCH_FAIL "%arguments% cannot be a character's original class, because you can't dual from that class"
   END
END

DEFINE_PATCH_FUNCTION CRE_read_original_class RET value BEGIN
   SPRINT value none
   PATCH_FOR_EACH class IN
   fighter mage cleric thief druid ranger BEGIN
      LPF "CRE_read_original_class_%class%" RET this_value=value END
      PATCH_IF this_value=1 BEGIN
         SPRINT value "%class%"
      END
   END

END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               data-field edits involving lookup
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ACTION_DEFINE_ASSOCIATIVE_ARRAY ~cre_ids_fields~ BEGIN
   animation => ~0x28,SHORT,ANIMATE~
   allegiance => ~0x270,BYTE,EA~
   general => ~0x271,BYTE,general~
   race => ~0x272,BYTE,race~
   class => ~0x273,BYTE,class~
   gender => ~0x275,BYTE,gender~
   alignment => ~0x27b,BYTE,align~
   kit_vanilla => ~0x244,LONG_REVERSED,kit~
   kit => ~0x244,LONG_REVERSED,dw#kit~
END

LAUNCH_ACTION_FUNCTION build_IDS_data_field_editors STR_VAR lookup_table=cre_ids_fields function_prefix=CRE END

// we'll overwrite gender by hand to also set the Sex field

DEFINE_PATCH_FUNCTION ~CRE_gender~
    STR_VAR arguments=""
BEGIN
  PATCH_IF "%arguments%" STRING_COMPARE no_change BEGIN
    SET value = IDS_OF_SYMBOL (gender "%arguments%")
    PATCH_IF value>0 BEGIN
            WRITE_BYTE 0x275 value
			PATCH_MATCH "%arguments%" WITH
			male BEGIN
               WRITE_BYTE 0x237 1			
			END
			female BEGIN
               WRITE_BYTE 0x237 2
            END
			DEFAULT
			END
    END ELSE BEGIN
            LPF warning STR_VAR warning= "tried to set nonexistent %idsfile% entry %arguments%" END
   END
  END
END


// kit needs special treatment

COPY_EXISTING kit.ids "override/dw#kit.ids"
      COUNT_2DA_ROWS 2 rowcount
      SET thisrow=0
      WHILE thisrow<rowcount BEGIN
         READ_2DA_ENTRY thisrow 0 2 kitnum
         PATCH_IF kitnum=0 BEGIN
            REMOVE_2DA_ROW thisrow 2
            SET rowcount = rowcount - 1
         END ELSE BEGIN
            SET thisrow += 1
         END
      END
      APPEND_FILE ~%scsroot%/sfo/dw#kit.ids~

DEFINE_PATCH_FUNCTION CRE_kit
    STR_VAR arguments=""
BEGIN
    TO_UPPER arguments
    PATCH_MATCH ~%arguments%~ WITH
    NO_CHANGE BEGIN END
    ASSASSIN BEGIN
       LPF CRE_kit_vanilla STR_VAR arguments=ASSASIN END
    END
    BARBARIAN BEGIN
         WRITE_LONG 0x244 0x4000
    END
    WILDMAGE BEGIN
         WRITE_LONG 0x244 0x8000
    END
    ARCHER BEGIN
       LPF CRE_kit_vanilla STR_VAR arguments=FERALAN END
    END
    ABJURER CONJURER DIVINER ILLUSIONIST TRANSMUTER ENCHANTER NECROMANCER INVOKER BEGIN
       LPF CRE_kit_vanilla STR_VAR arguments= ~MAGESCHOOL_%arguments%~ END
    END
    AVENGER BEGIN
         LPF CRE_kit_vanilla STR_VAR arguments=BEASTFRIEND END
    END
    NO_KIT NONE BEGIN
         WRITE_LONG 0x244 0
    END
    DEFAULT
       LPF CRE_kit_vanilla STR_VAR arguments END
    END
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               set movement rate (code adapted from aTweaks)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_movement STR_VAR arguments="" BEGIN
   PATCH_IF "%arguments%" STRING_COMPARE no_change BEGIN
       SET move=~%arguments%~
       LPF delete_entry STR_VAR type=effect file_ext=CRE arguments=~opcode is_in [126 176]~ END
       LPF add_entry_inline STR_VAR file_ext=CRE type=effect arguments=~opcode=>176 target=>1 timing=>9 parameter2=>1 parameter1=>%move%~ END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               strip scripts
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_strip_script  /// takes as argument list of scripts
      STR_VAR arguments=""
BEGIN
      PATCH_IF ~%arguments%~ STRING_EQUAL_CASE all BEGIN
           WRITE_ASCII 0x248 ~~ (0x28)
      END ELSE BEGIN

      PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
       LPF return_first_entry STR_VAR list= ~%arguments%~ RET arguments=list script=entry END
       FOR (i=0x248;i<0x270;i=i+8) BEGIN
          READ_ASCII i ~current_script~
          PATCH_IF ~%current_script%~ STRING_EQUAL_CASE ~%script%~ BEGIN
             WRITE_ASCII i ~~ (8)
          END
       END
       LPF CRE_strip_script STR_VAR arguments= ~%arguments%~ END
      END
      END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_strip_script") ""


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               swap scripts
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_swap_script  /// takes as argument hash of maps
      STR_VAR arguments=""
BEGIN
      PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
       LPF return_first_pair STR_VAR list=~%arguments%~ RET arguments=list oldscript=key newscript=value END
       FOR (i=0x248;i<0x270;i=i+8) BEGIN
          READ_ASCII i ~current_script~
          PATCH_IF ~%current_script%~ STRING_EQUAL_CASE ~%oldscript%~ BEGIN
             WRITE_ASCIIE i ~%newscript%~ (8)
          END
       END
       LPF CRE_swap_script STR_VAR arguments END
      END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_swap_script") ""


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               invert scripts
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_invert_scripts  /// takes as argument hash of maps
      STR_VAR arguments=""
BEGIN
      PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
       LPF return_first_pair STR_VAR list= ~%arguments%~ RET arguments=list oldscript=key newscript=value END
       FOR (i=0x248;i<0x270;i=i+8) BEGIN
          READ_ASCII i ~current_script~
          PATCH_IF ~%current_script%~ STRING_EQUAL_CASE ~%oldscript%~ BEGIN
             WRITE_ASCIIE i ~%newscript%~ (8)
          END
          PATCH_IF ~%current_script%~ STRING_EQUAL_CASE ~%newscript%~ BEGIN
             WRITE_ASCIIE i ~%oldscript%~ (8)
          END
       END
       LPF CRE_invert_scripts STR_VAR arguments END
      END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_invert_scripts") ""

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               enforce script order (argument is "X above Y" or "X below Y")
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_enforce_script_order
    STR_VAR arguments=""
BEGIN
   LPF return_first_entry STR_VAR list= ~%arguments%~ RET script1=entry list=list END
   LPF return_first_entry STR_VAR list RET list=list abovebelow=entry END
   PATCH_IF (~%abovebelow%~ STRING_COMPARE_CASE ~above~ && ~%abovebelow%~ STRING_COMPARE_CASE ~below~) BEGIN
      LPF warning STR_VAR ~Warning: malformed argument in CRE_enforce_script_order~ END
   END
   LPF return_first_entry STR_VAR list RET list=list script2=entry END
   PATCH_IF (~%abovebelow%~ STRING_EQUAL_CASE above) BEGIN
      SPRINT top ~%script1%~
      SPRINT bottom ~%script2%~
   END ELSE BEGIN
      SPRINT top ~%script2%~
      SPRINT bottom ~%script1%~
      TO_LOWER top
      TO_LOWER bottom
   END
   SET top_loc=~-1~
   SET bottom_loc=~-1~
   FOR (i=0x248;i<0x268;i+=8) BEGIN
      READ_ASCII i script
      TO_LOWER script
      PATCH_MATCH ~%script%~ WITH
         ~%top%~ BEGIN
            SET top_loc=i
         END
         ~%bottom%~ BEGIN
            SET bottom_loc=i
         END
         DEFAULT END
   END
   PATCH_IF ((top_loc>bottom_loc) && (bottom_loc>0)) BEGIN
         WRITE_ASCIIE top_loc ~%bottom%~ (8)
         WRITE_ASCIIE bottom_loc ~%top%~ (8)
   END


END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_enforce_script_order") ""


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              slot in this script where you can find space, from bottom up
/////////////              if the argument has the form "script1 above script2", insert the script script1 immediately
/////////////              above script2. Return the location of the new script.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_insert_script
     STR_VAR
         arguments=""
         filename=""
     RET new_loc
BEGIN SET success=0
          new_loc=~-1~
     // parse the argument
      LPF return_first_entry STR_VAR list= ~%arguments%~ RET script_new=entry list=list END
      PATCH_IF ~%list%~ STRING_COMPARE_CASE ~~ BEGIN // it's a relative insertion
        LPF return_first_entry STR_VAR list RET loc_instruction=entry list=list END
        LPF strip_spaces_from_string STR_VAR string= ~%list%~ RET script_old=string END
        // find the old script
        LPF CRE_locate_script STR_VAR script= ~%script_old%~ RET loc=value END
        PATCH_IF loc>=0 BEGIN
              LPF CRE_bump_down INT_VAR loc RET value=value END
              PATCH_IF value=1 BEGIN
                 SET high=loc
                 SET low=loc+8
                 SET success=1
              END ELSE BEGIN
                 LPF CRE_bump_up INT_VAR loc RET value=value END
                 PATCH_IF value=1 BEGIN
                    SET high=loc - 8
                    SET low=loc
                    SET success=1
                 END
              END
              PATCH_IF success=1 BEGIN
               TO_UPPER ~loc_instruction~
               PATCH_MATCH ~%loc_instruction%~ WITH
               above before BEGIN
                  WRITE_ASCIIE high ~%script_new%~ (8)
                  WRITE_ASCIIE low ~%script_old%~ (8)
                  SET new_loc=high
               END
               below after BEGIN
                  WRITE_ASCIIE high ~%script_old%~ (8)
                  WRITE_ASCIIE low ~%script_new%~ (8)
                  SET new_loc=low
               END
               DEFAULT
                 LPF warning STR_VAR warning= ~Unrecognised command %arguments% in insert_script~ END
               END
              END
        END
      END ELSE BEGIN // it's straightforward
       FOR (i=0x268;i>0x240;i=i - 8) BEGIN
        READ_ASCII i ~test~
        PATCH_IF ~%test%~ STRING_EQUAL_CASE ~~ OR ~%test%~ STRING_EQUAL_CASE ~none~ BEGIN
           SET success=1
           SET new_loc=i
           WRITE_ASCIIE i ~%script_new%~ (8)
           SET i=0
        END
       END
      END
      PATCH_IF success=0 BEGIN
          LAUNCH_PATCH_FUNCTION warning STR_VAR warning= "Failed to insert script %arguments% in file %filename%" END
      END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_insert_script") ""


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_locate_script // find the location of this script
        STR_VAR script=""
        RET value
BEGIN
        SET value= ~-1~
        FOR (i=0x248;i<0x270;i+=8) BEGIN
           READ_ASCII i test
           PATCH_IF ~%test%~ STRING_EQUAL_CASE ~%script%~ BEGIN
              SET value=i
              SET i=0x270
           END
        END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_first_gap_below // find the first gap below location loc
        INT_VAR loc=0x248
        RET value
BEGIN
        SET value= ~-1~
        FOR (i=loc;i<0x270;i+=8) BEGIN
           READ_ASCII i test
           PATCH_IF ~%test%~ STRING_EQUAL_CASE ~~ OR ~%test%~ STRING_EQUAL_CASE ~none~ BEGIN
              SET value=i
              SET i=0x270
           END
        END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_first_gap_above // find the first gap above location loc
        INT_VAR loc=0x248
        RET value
BEGIN
        SET value= ~-1~
        FOR (i=loc;i>0x240;i=i - 8) BEGIN
           READ_ASCII i test
           PATCH_IF ~%test%~ STRING_EQUAL_CASE ~~ OR ~%test%~ STRING_EQUAL_CASE ~none~ BEGIN
              SET value=i
              SET i=0x240
           END
        END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_bump_down // try to create a space below script at loc by bumping scripts down; return 1 if successful
        INT_VAR loc=0x248
        RET value
BEGIN
        SET value= 0
        LPF CRE_first_gap_below INT_VAR loc RET gap=value END
        PATCH_IF gap>=0 BEGIN
           FOR (i=gap - 8;i>loc;i=i - 8) BEGIN
              READ_ASCII i temp
              WRITE_ASCIIE (i+8) ~%temp%~ (8)
           END
           WRITE_ASCII (loc+8) ~~ (8)
           SET value=1
        END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_bump_up // try to create a space above script at loc by bumping scripts up; return 1 if successful
        INT_VAR loc=0x248
        RET value
BEGIN
        SET value= 0
        LPF CRE_first_gap_above INT_VAR loc RET gap=value END
        PATCH_IF gap>=0 BEGIN
           FOR (i=gap+8;i<loc;i+=8) BEGIN
              READ_ASCII i temp
              WRITE_ASCIIE (i - 8) ~%temp%~ (8)
           END
           WRITE_ASCII (loc - 8) ~~ (8)
           SET value=1
        END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               rearrange scripts and add a new one
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION CRE_insert_script_low
     STR_VAR
         arguments=""
         filename=""
BEGIN
     FOR (i=0x268;i>0x240;i=i - 8) BEGIN
        READ_ASCII i ~test~
        SET blank=0
        PATCH_IF ~%test%~ STRING_EQUAL_CASE ~~ OR ~%test%~ STRING_EQUAL_CASE ~none~ BEGIN
           SET blank=i
           SET i=0
        END
     END
     PATCH_IF blank=0 BEGIN // merge the last two scripts, but check both exist first!
          READ_ASCII 0x260 top
          READ_ASCII 0x268 bottom
          INNER_ACTION BEGIN
                ACTION_IF FILE_EXISTS_IN_GAME "%top%.bcs" BEGIN
                   OUTER_SET top_exists=1
                END ELSE BEGIN
                   OUTER_SET top_exists=0
                END
                ACTION_IF FILE_EXISTS_IN_GAME "%bottom%.bcs" BEGIN
                   OUTER_SET bottom_exists=1
                END ELSE BEGIN
                   OUTER_SET bottom_exists=0
                END
                ACTION_IF top_exists && bottom_exists BEGIN
                   LAF find_unique_filename STR_VAR extension=bcs RET script=filename END
                   LAF merge_scripts STR_VAR top bottom script END
                END
          END
          PATCH_IF top_exists && bottom_exists BEGIN
             WRITE_ASCIIE 0x260 "%script%" (8)
             LPF warning STR_VAR warning="found space for script %arguments% in file %filename% by merging %top%.bcs and %bottom%.bcs into %script%.bcs" END
          END ELSE BEGIN
             PATCH_IF bottom_exists BEGIN // in which case, top doesn't exist
                WRITE_ASCIIE 0x260 "%bottom%" (8)
             END // if it doesn't exist, we just overwrite bottom
          END
          WRITE_ASCIIE 0x268 "%arguments%" (8)
     END ELSE BEGIN
           FOR (i=blank;i<0x268;i=i+8) BEGIN
              READ_ASCII i+8 ~move~
              WRITE_ASCIIE i ~%move%~ (8)
           END
           WRITE_ASCIIE 0x268 ~%arguments%~ (8)
     END
END

DEFINE_PATCH_FUNCTION CRE_insert_script_high
     STR_VAR
         arguments=""
         filename=""
BEGIN
     FOR (i=0x248;i<0x270;i=i + 8) BEGIN
        READ_ASCII i ~test~
        SET blank=0
        PATCH_IF ~%test%~ STRING_EQUAL_CASE ~~ OR ~%test%~ STRING_EQUAL_CASE ~none~ BEGIN
           SET blank=i
           SET i=0x270
        END
     END
     PATCH_IF blank=0 BEGIN // merge the first two scripts, but check both exist first!
          READ_ASCII 0x248 top
          READ_ASCII 0x250 bottom
          INNER_ACTION BEGIN
                ACTION_IF FILE_EXISTS_IN_GAME "%top%.bcs" BEGIN
                   OUTER_SET top_exists=1
                END ELSE BEGIN
                   OUTER_SET top_exists=0
                END
                ACTION_IF FILE_EXISTS_IN_GAME "%bottom%.bcs" BEGIN
                   OUTER_SET bottom_exists=1
                END ELSE BEGIN
                   OUTER_SET bottom_exists=0
                END
                ACTION_IF top_exists && bottom_exists BEGIN
                   LAF find_unique_filename STR_VAR extension=bcs RET script=filename END
                   LAF merge_scripts STR_VAR top bottom script END
                END
          END
          PATCH_IF top_exists && bottom_exists BEGIN
             WRITE_ASCIIE 0x250 "%script%" (8)
             LPF warning STR_VAR warning="found space for script %arguments% in file %filename% by merging %top%.bcs and %bottom%.bcs into %script%.bcs" END
          END ELSE BEGIN
             PATCH_IF top_exists BEGIN // in which case, bottom doesn't exist
                WRITE_ASCIIE 0x250 "%top%" (8)
             END // if it doesn't exist, we just overwrite top
          END
          WRITE_ASCIIE 0x248 "%arguments%" (8)
     END ELSE BEGIN
           FOR (i=blank;i>0x248;i=i - 8) BEGIN
              READ_ASCII i - 8 ~move~
              WRITE_ASCIIE i ~%move%~ (8)
           END
           WRITE_ASCIIE 0x248 ~%arguments%~ (8)
     END
END

DEFINE_PATCH_FUNCTION CRE_insert_script_second
     STR_VAR
         arguments=""
         filename=""
BEGIN
     FOR (i=0x250;i<0x270;i=i + 8) BEGIN
        READ_ASCII i ~test~
        SET blank=0
        PATCH_IF ~%test%~ STRING_EQUAL_CASE ~~ OR ~%test%~ STRING_EQUAL_CASE ~none~ BEGIN
           SET blank=i
           SET i=0x270
        END
     END
     PATCH_IF blank=0 BEGIN // merge the first two scripts, but check both exist first!
          READ_ASCII 0x250 top
          READ_ASCII 0x258 bottom
          INNER_ACTION BEGIN
                ACTION_IF FILE_EXISTS_IN_GAME "%top%.bcs" BEGIN
                   OUTER_SET top_exists=1
                END ELSE BEGIN
                   OUTER_SET top_exists=0
                END
                ACTION_IF FILE_EXISTS_IN_GAME "%bottom%.bcs" BEGIN
                   OUTER_SET bottom_exists=1
                END ELSE BEGIN
                   OUTER_SET bottom_exists=0
                END
                ACTION_IF top_exists && bottom_exists BEGIN
                   LAF find_unique_filename STR_VAR extension=bcs RET script=filename END
                   LAF merge_scripts STR_VAR top bottom script END
                END
          END
          PATCH_IF top_exists && bottom_exists BEGIN
             WRITE_ASCIIE 0x258 "%script%" (8)
             LPF warning STR_VAR warning="found space for script %arguments% in file %filename% by merging %top%.bcs and %bottom%.bcs into %script%.bcs" END
          END ELSE BEGIN
             PATCH_IF top_exists BEGIN // in which case, bottom doesn't exist
                WRITE_ASCIIE 0x258 "%top%" (8)
             END // if it doesn't exist, we just overwrite top
          END
          WRITE_ASCIIE 0x250 "%arguments%" (8)
     END ELSE BEGIN
           FOR (i=blank;i>0x250;i=i - 8) BEGIN
              READ_ASCII i - 8 ~move~
              WRITE_ASCIIE i ~%move%~ (8)
           END
           WRITE_ASCIIE 0x250 ~%arguments%~ (8)
     END
END

DEFINE_PATCH_FUNCTION CRE_insert_script_above // legacy syntax
     STR_VAR
         arguments=""
         filename=""
BEGIN
   LPF CRE_insert_script_high STR_VAR arguments filename END
END

DEFINE_PATCH_FUNCTION CRE_insert_script_below // legacy syntax
     STR_VAR
         arguments=""
         filename=""
BEGIN
   LPF CRE_insert_script_low STR_VAR arguments filename END
END



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               looks for a script anywhere and returns 1 if true
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_match_script
     STR_VAR
         arguments=""
     RET
         value
BEGIN
   SET value=0
   FOR (i=0x248;i<0x270;i=i+8) BEGIN
      READ_ASCII i ~script~
      PATCH_IF ~%script%~ STRING_EQUAL_CASE ~%arguments%~ BEGIN
         SET value=1
         SET i=0x270
      END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               add a spell by name alone (if spell has form SPELL(x), add it x times)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION ~QUICK_ADD_SPELL~
    INT_VAR as_known=0
    STR_VAR ~spellname~=""
BEGIN
    LPF return_function_and_argument STR_VAR input= ~%spellname%~ RET spellname=function number=argument END

    PATCH_IF ~%number%~ STRING_EQUAL_CASE ~~ BEGIN
       SET number=1
    END
    LPF deabbreviate_spellname STR_VAR input= ~%spellname%~ RET spellname=spellname END
    LPF get_spellcode STR_VAR input= ~%spellname%~ RET spell=value END
    INNER_PATCH_SAVE spell ~%spell%~ BEGIN
      REPLACE_TEXTUALLY ~%percentage%~ ~~
    END
    TO_UPPER spell
    PATCH_IF VARIABLE_IS_SET ~%spellname%_LEVEL~ BEGIN
      SET ~spell_level~=  ~%%spellname%_LEVEL%~
      SPRINT ~spell_type~ EVALUATE_BUFFER ~%%spellname%_TYPE%~
    END ELSE
    PATCH_IF VARIABLE_IS_SET ~RESREF_%spell%_LEVEL~ BEGIN
      SET ~spell_level~=  ~%RESREF_%spell%_LEVEL%~
      SPRINT ~spell_type~ EVALUATE_BUFFER ~%RESREF_%spell%_TYPE%~
    END ELSE BEGIN
      // hardcode spells in SCS's trigger space as innate
      PATCH_MATCH "%spell%" WITH
      "DW#MS.*" "DW#SQ.*" "DW#TG.*" BEGIN
       SPRINT spell_type innate
      END
      DEFAULT
       INNER_ACTION BEGIN
         COPY_EXISTING ~%spell%.spl~ ~override~
               LPF SPL_read_spell_type RET spell_type=value END
               LPF SPL_read_level RET spell_level=value END
               SET spell_level -= 1
         BUT_ONLY
       END
      END
    END
    PATCH_IF "%spell_type%" STRING_EQUAL_CASE innate BEGIN
       SET spell_level=0
    END
    // yes, this is hideous, but if there's a way to send level to ADD_MEMORIZED_SPELL as a variable, I don't know it
    PATCH_IF as_known BEGIN
       PATCH_MATCH "%spell_level%" WITH
       0 BEGIN
             ADD_KNOWN_SPELL "%spell%" #0 "%spell_type%"
       END
       1 BEGIN
             ADD_KNOWN_SPELL "%spell%" #1 "%spell_type%"
       END
       2 BEGIN
             ADD_KNOWN_SPELL "%spell%" #2 "%spell_type%"
       END
       3 BEGIN
             ADD_KNOWN_SPELL "%spell%" #3 "%spell_type%"
       END
       4 BEGIN
             ADD_KNOWN_SPELL "%spell%" #4 "%spell_type%"
       END
       5 BEGIN
             ADD_KNOWN_SPELL "%spell%" #5 "%spell_type%"
       END
       6 BEGIN
             ADD_KNOWN_SPELL "%spell%" #6 "%spell_type%"
       END
       7 BEGIN
             ADD_KNOWN_SPELL "%spell%" #7 "%spell_type%"
       END
       8 BEGIN
             ADD_KNOWN_SPELL "%spell%" #8 "%spell_type%"
       END
       DEFAULT // assume level 0
             ADD_KNOWN_SPELL "%spell%" #0 "%spell_type%"
       END
    END ELSE BEGIN
       PATCH_MATCH "%spell_level%" WITH
       0 BEGIN
             ADD_MEMORIZED_SPELL "%spell%" #0 "%spell_type%" (number)
       END
       1 BEGIN
             ADD_MEMORIZED_SPELL "%spell%" #1 "%spell_type%" (number)
       END
       2 BEGIN
             ADD_MEMORIZED_SPELL "%spell%" #2 "%spell_type%" (number)
       END
       3 BEGIN
             ADD_MEMORIZED_SPELL "%spell%" #3 "%spell_type%" (number)
       END
       4 BEGIN
             ADD_MEMORIZED_SPELL "%spell%" #4 "%spell_type%" (number)
       END
       5 BEGIN
             ADD_MEMORIZED_SPELL "%spell%" #5 "%spell_type%" (number)
       END
       6 BEGIN
             ADD_MEMORIZED_SPELL "%spell%" #6 "%spell_type%" (number)
       END
       7 BEGIN
             ADD_MEMORIZED_SPELL "%spell%" #7 "%spell_type%" (number)
       END
       8 BEGIN
             ADD_MEMORIZED_SPELL "%spell%" #8 "%spell_type%" (number)
       END
       DEFAULT // assume level 0
             ADD_MEMORIZED_SPELL "%spell%" #0 "%spell_type%" (number)
       END

    END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               helper function to add all SPPR spells permitted by class/level/alignment to the creature as known
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_add_all_priest_spells
BEGIN
     INNER_ACTION BEGIN
        LAM read_in_hidespl // (do it now because remove_spell_of_type needs it anyway)
     END
     // wipe extant spells
     LPF CRE_remove_spell_of_type INT_VAR skip_hidden=1 known_only=1 STR_VAR arguments=SPPR END
     // data collection
     LPF CRE_read_class RET class=value END
     LPF CRE_read_level1 RET level1=value END
     LPF CRE_read_level2 RET level2=value END
     LPF CRE_read_level3 RET level3=value END
     PATCH_MATCH "%class%" WITH
     CLERIC CLERIC_MAGE CLERIC_THIEF BEGIN
        SET type=1 // cleric
        SPRINT list mxsplprs
        SET level=level1
     END
     FIGHTER_CLERIC BEGIN
        SET type=1 // cleric
        SPRINT list mxsplprs
        SET level=level2
     END
     FIGHTER_MAGE_CLERIC BEGIN
        SET type=1 // cleric
        SPRINT list mxsplprs
        SET level=level3
     END
     PALADIN BEGIN
        SET type=1 // cleric
        SPRINT list mxsplpal
        SET level=level1
     END
     DRUID BEGIN
        SET type=2 // druid
        SPRINT list mxspldru
        SET level=level1
     END
     RANGER BEGIN
        SET type=2 // druid
        SPRINT list mxsplran
        SET level=level1
     END
     FIGHTER_DRUID BEGIN
        SET type=2 // druid
        SPRINT list mxspldru
        SET level=level2
     END
     CLERIC_RANGER BEGIN
        SET type=3 // both
        SPRINT list mxsplprs
        SET level=level1
     END
     DEFAULT // no spells
        SET level=0
     END
     PATCH_IF level>0 BEGIN
       // find highest level known
       INNER_ACTION BEGIN
         COPY_EXISTING "%list%.2da" "%workspace%"
              COUNT_2DA_COLS colcount // also gives # spell levels+1
              COUNT_2DA_ROWS colcount rowcount
              SET highest=0
              FOR (i=0;i<rowcount;i+=1) BEGIN
                 READ_2DA_ENTRY i 0 colcount this_level
                 PATCH_IF this_level=level BEGIN
                    SET highest=colcount - 1 // first guess
                    FOR (j=1;j<colcount;j+=1) BEGIN
                       READ_2DA_ENTRY i j colcount number
                       PATCH_IF number=0 BEGIN
                           SET highest = j - 1
                           SET j=colcount
                       END
                    END
                    SET i=rowcount
                 END
              END
         BUT_ONLY
       END
       // get alignment
       LPF CRE_read_alignment RET alignment=value END
       // read in maximums set via SPELLS.2da
       INNER_ACTION BEGIN
          COPY_EXISTING spells.2da "%workspace%"
                 COUNT_2DA_ROWS 8 rowcount
                 FOR (i=0;i<rowcount;i+=1) BEGIN
                    READ_2DA_ENTRY i 0 8 castertype
                    PATCH_IF "%castertype%" STRING_EQUAL PRIEST BEGIN
                       FOR (j=1;j<8;j+=1) BEGIN
                          READ_2DA_ENTRY i j 8 num
                          SET $max_at_level("%j%")=num
                       END
                    END
                 END
          BUT_ONLY
       END
       // go through spells
       SPRINT spells_to_add ""
       FOR (lev=1;lev<=highest;lev+=1) BEGIN
        SET max_here=$max_at_level("%lev%")
        FOR (spellcode=lev*100+1;spellcode<=lev*100+max_here;spellcode+=1) BEGIN
          PATCH_IF (FILE_EXISTS_IN_GAME "SPPR%spellcode%.spl") && (!VARIABLE_IS_SET $spell_is_hidden("sppr%spellcode%")) BEGIN
              INNER_ACTION BEGIN
                 COPY_EXISTING "sppr%spellcode%.spl" "%workspace%"
                        SET not_allowed=0
                        PATCH_MATCH type WITH // class check
                        1 BEGIN
                              LPF SPL_read_unusable_cleric RET not_allowed=value END
                        END
                        2 BEGIN
                              LPF SPL_read_unusable_druid RET not_allowed=value END
                        END
                        DEFAULT
                        END
                        PATCH_IF not_allowed=0 BEGIN //G/N/E align check
                           PATCH_MATCH "%alignment%" WITH
                           LAWFUL_GOOD NEUTRAL_GOOD CHAOTIC_GOOD BEGIN
                              LPF SPL_read_unusable_good_priest RET not_allowed=value END
                           END
                           LAWFUL_NEUTRAL NEUTRAL CHAOTIC_NEUTRAL BEGIN
                              LPF SPL_read_unusable_GEneutral_priest RET not_allowed=value END
                           END
                           LAWFUL_EVIL NEUTRAL_EVIL CHAOTIC_EVIL BEGIN
                              LPF SPL_read_unusable_evil_priest RET not_allowed=value END
                           END
                           DEFAULT END
                        END
                        PATCH_IF not_allowed=0 BEGIN  // L/C/N align check
                           PATCH_MATCH "%alignment%" WITH
                           LAWFUL_GOOD LAWFUL_NEUTRAL LAWFUL_EVIL BEGIN
                              LPF SPL_read_unusable_lawful_priest RET not_allowed=value END
                           END
                           NEUTRAL_GOOD NEUTRAL NEUTRAL_EVIL BEGIN
                              LPF SPL_read_unusable_LCneutral_priest RET not_allowed=value END
                           END
                           CHAOTIC_GOOD CHAOTIC_NEUTRAL CHAOTIC_EVIL BEGIN
                              LPF SPL_read_unusable_chaotic_priest RET not_allowed=value END
                           END
                           DEFAULT END
                        END
                 BUT_ONLY
              END
              PATCH_IF not_allowed=0 BEGIN
                 SPRINT spells_to_add "%spells_to_add% sppr%spellcode%"
              END ELSE BEGIN
                 REMOVE_MEMORIZED_SPELL ~sppr%spellcode%~
              END
          END // end of patch_if
       END // end of inner loop
     END // end of outer loop
     LPF CRE_add_known_spells STR_VAR arguments="%spells_to_add%" END
    END // end of condition to do anything at all
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_add_all_priest_spells") ""


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               add spells from a list
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION CRE_add_spells
     STR_VAR arguments = ""
BEGIN
       PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
          LPF return_first_entry STR_VAR list= ~%arguments%~ RET spellname=entry arguments=list END
          PATCH_IF "%spellname%" STRING_COMPARE_CASE "null" BEGIN
             LPF QUICK_ADD_SPELL INT_VAR as_known=0 STR_VAR spellname END
          END
          LPF CRE_add_spells STR_VAR arguments END
       END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_add_spells") ""


DEFINE_PATCH_FUNCTION CRE_add_known_spells
     STR_VAR arguments = ""
BEGIN
      PATCH_MATCH "%arguments%" WITH
      " *" BEGIN END // we're done
      "all" BEGIN
         LPF CRE_add_all_priest_spells END
      END
      DEFAULT
       PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
          LPF return_first_entry STR_VAR list= ~%arguments%~ RET spellname=entry arguments=list END
          PATCH_IF "%spellname%" STRING_COMPARE_CASE "null" BEGIN
              LPF QUICK_ADD_SPELL INT_VAR as_known=1 STR_VAR spellname END
          END
          LPF CRE_add_known_spells STR_VAR arguments END
       END
      END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_add_known_spells") ""


DEFINE_PATCH_FUNCTION CRE_remove_spells
     STR_VAR arguments = ""
BEGIN
     PATCH_MATCH ~%arguments%~ WITH
     all BEGIN
        REMOVE_KNOWN_SPELLS
        REMOVE_MEMORIZED_SPELLS
     END
     dw BEGIN
        LPF CRE_remove_spell_of_type STR_VAR arguments="DW#" END
     END
     cleric priest BEGIN
        LPF CRE_remove_spell_of_type STR_VAR arguments=SPPR END
     END
     mage wizard BEGIN
        LPF CRE_remove_spell_of_type STR_VAR arguments=SPWI END
     END
     innate BEGIN
        LPF CRE_remove_spell_of_type STR_VAR arguments=SPIN END
     END
     DEFAULT
        LPF process_string_list STR_VAR list = ~%arguments%~ function=CRE_remove_spell END
     END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_remove_spells") ""



DEFINE_PATCH_FUNCTION CRE_remove_spell_of_type
     INT_VAR skip_hidden=0
             known_only=0
     STR_VAR arguments=""
BEGIN
     SPRINT ~list~ ~~
     SPRINT file_ext CRE
     PATCH_IF skip_hidden BEGIN
       INNER_ACTION BEGIN
        LAM read_in_hidespl
       END
     END
     SET length=STRING_LENGTH "%arguments%"
     PATCH_FOR_EACH entry_type IN known_spell memorized_spell BEGIN
      LAUNCH_PATCH_MACRO get_offset_array
      PHP_EACH offset_array AS int=>spl_off BEGIN
        READ_ASCII spl_off check (length)
        READ_ASCII spl_off temp
        PATCH_IF ~%check%~ STRING_EQUAL_CASE ~%arguments%~ BEGIN
            PATCH_IF skip_hidden BEGIN
               TO_LOWER temp
               PATCH_IF !VARIABLE_IS_SET $spell_is_hidden("%temp%") BEGIN
                  SPRINT list "%list% %temp%"
               END
            END ELSE BEGIN
               SPRINT ~list~ ~%list% %temp%~
            END
        END
      END
     END
     WHILE ~%list%~ STRING_COMPARE_CASE ~~ BEGIN
        LPF return_first_entry STR_VAR list RET spell=entry list=list END
        PATCH_IF !known_only BEGIN
           REMOVE_MEMORIZED_SPELL ~%spell%~
        END
        REMOVE_KNOWN_SPELL ~%spell%~
     END
END

DEFINE_PATCH_FUNCTION CRE_remove_spell
     STR_VAR arguments = ""
BEGIN
    LPF get_spellcode STR_VAR input="%arguments%" RET spellcode=value END
    REMOVE_MEMORIZED_SPELL ~%spellcode%~
     REMOVE_KNOWN_SPELL ~%spellcode%~
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              give immunity to a spell (opcode 206)
/////////////
/////////////              if we use "arguments" assume it's a string of entries
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_immunity_to_spell
       STR_VAR spellname=""
               spellcode=""
               arguments=""
BEGIN
       PATCH_IF ~%spellname%~ STRING_COMPARE_CASE ~~ BEGIN
              LPF deabbreviate_spellname STR_VAR input=  ~%spellname%~ RET spellname END
              PATCH_IF VARIABLE_IS_SET "%spellname%" BEGIN
                  SPRINT spellcode EVALUATE_BUFFER ~%%spellname%%~
              END ELSE BEGIN
                 SPRINT spellcode "%spellname%"
                 LPF warning STR_VAR warning="Spell %spellname% does not appear to exist" END
              END
       END
       PATCH_IF ~%spellcode%~ STRING_COMPARE_CASE ~~ BEGIN
         LPF add_entry_inline STR_VAR arguments =~opcode=>206 timing=>9 resource=>%spellcode%~ type=effect file_ext=CRE END
       END
       PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
          LPF return_first_entry STR_VAR list= ~%arguments%~ RET spell=entry arguments=list END
          INNER_ACTION BEGIN
                  ACTION_IF FILE_EXISTS_IN_GAME ~%spell%.spl~ BEGIN
                     OUTER_SPRINT spellcode ~%spell%~
                     OUTER_SPRINT spellname ~~
                  END ELSE BEGIN
                     OUTER_SPRINT spellname ~%spell%~
                     OUTER_SPRINT spellcode ~~
                  END
          END
          LPF CRE_immunity_to_spell STR_VAR arguments spellname spellcode END
       END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_immunity_to_spell") ""


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              give immunity to an animation (opcode 296)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_immunity_to_animation
       STR_VAR arguments=""
BEGIN
       PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
          LPF return_first_entry STR_VAR list= ~%arguments%~ RET entry=entry arguments=list END
         LPF add_entry_inline STR_VAR arguments =~opcode=>296 timing=>9 resource=>%entry%~ type=effect file_ext=CRE END
          LPF CRE_immunity_to_string STR_VAR arguments END
       END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_immunity_to_animation") ""


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              give immunity to a string (opcode 267)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_immunity_to_string
       STR_VAR arguments=""
BEGIN
       PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
          LPF return_first_entry STR_VAR list= ~%arguments%~ RET entry=entry arguments=list END
         LPF add_entry_inline STR_VAR arguments =~opcode=>267 timing=>9 parameter1=>%entry%~ type=effect file_ext=CRE END
          LPF CRE_immunity_to_string STR_VAR arguments END
       END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_immunity_to_string") ""

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              give immunity to an opcode (opcode 101)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_immunity_to_opcode
       STR_VAR arguments=""
BEGIN
       PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
          LPF return_first_entry STR_VAR list=~%arguments%~ RET entry=entry arguments=list END
         LPF delete_entry STR_VAR type=effect arguments=~opcode=101 and parameter2=%entry%~ file_ext=CRE END
         LPF add_entry_inline STR_VAR arguments =~opcode=>101 timing=>9 parameter2=>%entry%~ type=effect file_ext=CRE END
          LPF CRE_immunity_to_opcode STR_VAR arguments END
       END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_immunity_to_opcode") ""


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              give immunity to an icon (opcode 169)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_immunity_to_icon
       STR_VAR arguments=""
BEGIN
       PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
          LPF return_first_entry STR_VAR list= ~%arguments%~ RET entry=entry arguments=list END
         LPF add_entry_inline STR_VAR arguments =~opcode=>169 timing=>9 parameter2=>%entry%~ type=effect file_ext=CRE END
          LPF CRE_immunity_to_icon STR_VAR arguments END
       END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_immunity_to_icon") ""


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              enforce saving throws by class and level
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_enforce_saves
       STR_VAR arguments=""
BEGIN
       INNER_ACTION BEGIN
         LAM read_in_saving_throws
       END
       // initialise the enforced values
       PATCH_FOR_EACH save IN death wand polymorph breath spell BEGIN
          SET  ~enforced_%save%~ = 20
       END
       // read in class and decompose
       LPF CRE_read_class RET classlist=value END
       // go through each class, get its saves for the CRE's level, and update the record of the correct saves
       SET levelnum=1
       WHILE ~%classlist%~ STRING_COMPARE ~~ BEGIN
          LPF return_first_entry STR_VAR list= ~%classlist%~ separator ="_" RET classlist=list class=entry END
          TO_UPPER class
          PATCH_IF !VARIABLE_IS_SET $class_file_save_map( ~%class%~) BEGIN
             SPRINT core_type WAR
          END ELSE BEGIN
             SPRINT core_type $class_file_save_map( ~%class%~)
          END
          LPF ~CRE_read_level%levelnum%~ RET level=value END
          SET level=level<1?1:level
          SET level=level>maximum_character_level?maximum_character_level:level
          PATCH_FOR_EACH save IN death wand polymorph breath spell BEGIN
             SET possible = $saving_throw_value_base(~%core_type%~ ~%level%~ ~%save%~)
             SET  ~enforced_%save%~ =  ~enforced_%save%~ >possible ? possible :  ~enforced_%save%~
          END
          SET levelnum=levelnum+1
       END
       // do the comparison
       PATCH_FOR_EACH save IN death wand polymorph breath spell BEGIN
          LPF ~CRE_read_save_vs_%save%~ RET currentsave = value END
          SET possiblesave =  ~enforced_%save%~
          PATCH_MATCH ~%arguments%~ WITH
          at_worst
          BEGIN
             SET newsave=currentsave<possiblesave ? currentsave : possiblesave
          END
          at_best
          BEGIN
             SET newsave=currentsave>possiblesave ? currentsave : possiblesave
          END
          within_tolerance
          BEGIN
             LPF check_ini STR_VAR ini=save_tolerance RET tolerance=value END
             SET new=(ABS(possible - current))<tolerance ? possible : current
          END
          only_if_new
          BEGIN
             SET newsave=currentsave=100 ? possiblesave : currentsave
          END
          DEFAULT
             SET newsave=possiblesave
          END
          LPF ~CRE_save_vs_%save%~ INT_VAR arguments=newsave END
       END

END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              enforce THAC0 by class and level
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_enforce_thac0
       STR_VAR arguments=""
BEGIN
       CLEAR_ARRAY class_array
       CLEAR_ARRAY class_level
       CLEAR_ARRAY newthac0
       LPF CRE_read_class RET classlist=value END
       SET levelnum=1

       SET possible=99
       WHILE ~%classlist%~ STRING_COMPARE ~~ BEGIN
          LPF return_first_entry STR_VAR list= ~%classlist%~ separator ="_" RET classlist=list class=entry END
          LPF ~CRE_read_level%levelnum%~ RET level=value END
          PATCH_IF level=0 BEGIN
             SET level=1
          END
          PATCH_IF level>21 BEGIN
             SET level=21
          END
          PATCH_IF VARIABLE_IS_SET $thac0_table_row("%class%") BEGIN
             SET row=$thac0_table_row("%class%")
             READ_2DA_ENTRY_FORMER thac0_table_read row level thac0_here
             SET possible = (thac0_here < possible) ? thac0_here : possible
          END
      END
      PATCH_IF possible=99 BEGIN // must be a monster
         LPF CRE_read_level1 RET level1=value END
         SET possible = level1 > 20 ? 0 : (20 - level1)
      END

       LPF CRE_read_thac0 RET current=value END
       PATCH_MATCH ~%arguments%~ WITH
       at_worst
       BEGIN
             SET new=current<possible ? current : possible
       END
          at_best
       BEGIN
             SET new=current>possible ? current : possible
       END
          only_if_new
       BEGIN
             SET new=current=100 ? possible : current
       END
          within_tolerance
          BEGIN
             LPF check_ini STR_VAR ini=thac0_tolerance RET tolerance=value END
             SET new=(ABS(possible - current))<tolerance ? possible : current
       END
       DEFAULT
             SET new=possible
       END
       LPF CRE_thac0 INT_VAR arguments=new END
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////// enforce hit points by class and level (note that this gets it wrong for dual-classed characters; our algorithm is a weighted average by level)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_enforce_hp BEGIN
       CLEAR_ARRAY class_list_array
       LPF CRE_read_class RET classlist=value END
       SET levelnum=0
       SET hptotal_max=0
       SET hptotal_min=0
       LPF check_ini STR_VAR ini=hitpoint_percentage RET hitpoint_percentage=value END
       PATCH_IF hitpoint_percentage=0 BEGIN
          SET hitpoint_percentage=75
       END
       WHILE ~%classlist%~ STRING_COMPARE ~~ BEGIN
          SET levelnum=levelnum+1
          LPF return_first_entry STR_VAR list= ~%classlist%~ separator ="_" RET classlist=list class=entry END
          LPF ~CRE_read_level%levelnum%~ RET level=value END
          PATCH_IF VARIABLE_IS_SET $class_hp_maximum(~%class%~ ~%level%~) BEGIN
             SET hptotal_max=hptotal_max + $class_hp_maximum(~%class%~ ~%level%~)
             SET hptotal_min=hptotal_min + $class_hp_minimum(~%class%~ ~%level%~)
          END ELSE BEGIN
             SET hptotal_max=hptotal_max+8*level
             SET hptotal_min=hptotal_min+level
          END
          SPRINT $class_array( ~%class%~) ~~
       END
        SET hptotal = (hptotal_max * hitpoint_percentage + hptotal_min * (100 - hitpoint_percentage) ) / 100
      SET possible=hptotal / levelnum
       LPF CRE_read_hp_max RET current=value END
       PATCH_MATCH ~%arguments%~ WITH
       at_worst
       BEGIN
             SET new=current>possible ? current : possible
       END
          at_best
       BEGIN
             SET new=current<possible ? current : possible
       END
          only_if_new
       BEGIN
             SET new=current=65535 ? possible : current
       END
       DEFAULT
             SET new=possible
       END
       LPF CRE_hitpoints INT_VAR arguments=new END

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////// enforce animation type
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_enforce_animation
   STR_VAR arguments=""
BEGIN
   SET continue=1
   PATCH_IF ~%arguments%~ STRING_EQUAL_CASE only_if_new BEGIN
         LPF CRE_read_animation_code RET oldcode=value END
         PATCH_IF !(oldcode = 0xffff) BEGIN
            SET continue=0
         END
   END
   PATCH_IF continue=1 BEGIN
       // try by class_gender_race first
       LPF CRE_read_class RET class=value END
       LPF return_first_entry STR_VAR list= ~%class%~ separator = "_" RET class=entry END
       PATCH_MATCH ~%class%~ WITH
       ~DRUID~
       BEGIN
          SPRINT class CLERIC
       END
       ~PALADIN~ ~RANGER~
       BEGIN
          SPRINT class FIGHTER
       END
       ~SORCERER~
       BEGIN
          SPRINT class MAGE
       END
       ~BARD~
       BEGIN
          SPRINT class THIEF
       END
       DEFAULT
       END
       LPF CRE_read_race RET race=value END
       PATCH_MATCH ~%race%~ WITH
       ~HALF_ELF~
       BEGIN
          SPRINT race ELF
       END
       DEFAULT
       END
       LPF CRE_read_gender RET gender=value END
       SPRINT ~animation~ ~%class%_%gender%_%race%~
       SET animcode= IDS_OF_SYMBOL (~animate~ ~%animation%~)
       PATCH_IF animcode= ~-1~ BEGIN
          // try by race_gender
          SPRINT animation ~%race%_%gender%~
          SET animcode= IDS_OF_SYMBOL (~animate~ ~%animation%~)
       END
       PATCH_IF animcode= ~-1~ BEGIN
          // try by race
          SPRINT animation ~%race%~
          SET animcode= IDS_OF_SYMBOL (~animate~ ~%animation%~)
       END
       PATCH_IF !(animcode = ~-1~) BEGIN
          LPF CRE_animation_code INT_VAR arguments=animcode END
       END ELSE BEGIN
          LPF warning STR_VAR warning= ~Failed to find animation %class%_%gender%_%race%, %race%_%gender%, %race%, or bespoke setting~ END
       END
   END

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////// steal colourscheme
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_steal_colors_from
      STR_VAR arguments=""
BEGIN
      SET foundcolours=0
      INNER_ACTION BEGIN
         ACTION_IF FILE_EXISTS_IN_GAME ~%arguments%.cre~ BEGIN
              OUTER_SET foundcolours=1
              COPY_EXISTING ~%arguments%.cre~ ~override~
                    PATCH_FOR_EACH color IN metal minor major skin leather armor hair BEGIN
                       LPF ~CRE_read_color_%color%~ RET  ~color_%color%~ = value END
                    END
              BUT_ONLY
         END
      END
      PATCH_IF foundcolours=1 BEGIN
             PATCH_FOR_EACH color IN metal minor major skin leather armor hair BEGIN
                 LPF ~CRE_color_%color%~ INT_VAR arguments= ~color_%color%~ END
             END
      END ELSE BEGIN
            LPF warning STR_VAR warning= ~Tried to steal colors from %arguments%.cre, but it doesn't exist~ END
      END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////// quick colourscheme
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_colors
      STR_VAR arguments=""
BEGIN
      LPF return_first_entry STR_VAR list="%arguments%" RET entry list END
      WRITE_BYTE 0x2c entry
      LPF return_first_entry STR_VAR list RET entry list END
      WRITE_BYTE 0x2d entry
      LPF return_first_entry STR_VAR list RET entry list END
      WRITE_BYTE 0x2e entry
      LPF return_first_entry STR_VAR list RET entry list END
      WRITE_BYTE 0x2f entry
      LPF return_first_entry STR_VAR list RET entry list END
      WRITE_BYTE 0x30 entry
      LPF return_first_entry STR_VAR list RET entry list END
      WRITE_BYTE 0x31 entry
      LPF return_first_entry STR_VAR list RET entry list END
      WRITE_BYTE 0x32 entry
END


OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_colors") ""

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////// hand out a soundset
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_say_sounds
   STR_VAR arguments=""
BEGIN
   PATCH_IF "%arguments%" STRING_COMPARE "" BEGIN
      LPF return_first_pair STR_VAR list="%arguments%" RET key=key value=value arguments=list END
      DEFINE_ASSOCIATIVE_ARRAY sound_map BEGIN
          initial_meeting=>0xa4
          morale=>0xa8
          happy=>0xac
          battle_cry1=>0xc8
          battle_cry2=>0xcc
          attack1=>0xdc
          attack2=>0xe0
          damage=>0xec
          dying=>0xf0
          select_common1=>0x10c
          select_common2=>0x110
          select_common3=>0x114
          select_common4=>0x118
          select_common5=>0x11c
          select_common6=>0x120
          picked_pocket=>0x1b8

      END
      SET loc=$sound_map("%key%")
      SET val=RESOLVE_STR_REF ( ( AT "%value%"))
      WRITE_LONG loc val
      LPF CRE_say_sounds STR_VAR arguments END
   END
END

OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_say_sounds") ""

DEFINE_PATCH_FUNCTION CRE_say_sounds_literal
   STR_VAR arguments=""
BEGIN
   PATCH_IF "%arguments%" STRING_COMPARE "" BEGIN
      LPF return_first_pair STR_VAR list="%arguments%" RET key=key value=value arguments=list END
      DEFINE_ASSOCIATIVE_ARRAY sound_map BEGIN
          initial_meeting=>0xa4
          morale=>0xa8
          happy=>0xac
		  unhappy_breaking_point=>0xb8
          battle_cry1=>0xc8
          battle_cry2=>0xcc
          attack1=>0xdc
          attack2=>0xe0
          damage=>0xec
          dying=>0xf0
          select_common1=>0x10c
          select_common2=>0x110
          select_common3=>0x114
          select_common4=>0x118
          select_common5=>0x11c
          select_common6=>0x120
          picked_pocket=>0x1b8

      END
      SET loc=$sound_map("%key%")
      WRITE_LONG loc value
      LPF CRE_say_sounds_literal STR_VAR arguments END
   END
END

DEFINE_PATCH_FUNCTION wipe_soundset
   STR_VAR arguments=""
BEGIN
   FOR (i=0xa4;i<0x234;i+=4) BEGIN
      WRITE_LONG i "-1"
   END
END

OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_say_sounds_literal") ""


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////// steal soundset
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_steal_sounds_from
      STR_VAR arguments=""
BEGIN
      SET found=0
      INNER_ACTION BEGIN
         ACTION_IF FILE_EXISTS_IN_GAME ~%arguments%.cre~ BEGIN
              OUTER_SET found=1
              COPY_EXISTING ~%arguments%.cre~ ~override~
                    READ_ASCII 0xa4 sounddata (0x190)
              BUT_ONLY
         END
      END
      PATCH_IF found BEGIN
             WRITE_ASCIIE 0xa4 ~%sounddata%~ (0x190)
      END ELSE BEGIN
            LPF warning STR_VAR warning=~Tried to steal soundset from %arguments%.cre, but it doesn't exist~ END
      END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////// add a list of items
/////////////
///////////// syntax is add_items => ~string~
///////////// string is list in format ITEMNAME or ITEMNAME(arguments)
///////////// arguments is either (arg) or (arg,arg)
///////////// arg is either a slot name (case-insensitive), NOTEQUIP, or xNUM
///////////// NUM is either a number or n.m.o - in the latter case it's the number to go into each item-num slot
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_add_items
       INT_VAR replace=0
       STR_VAR arguments=""
BEGIN
       SET equip=1
       INNER_ACTION BEGIN
          LAUNCH_ACTION_MACRO read_in_item_types
       END
       WHILE ~%arguments%~ STRING_COMPARE ~~ BEGIN
          SPRINT ~slot~ ~NONE~
          SET num1=0
          SET num2=0
          SET num3=0
          SET twohanded=0
          LPF return_first_entry STR_VAR list= ~%arguments%~ RET entry=entry arguments=list END
          LPF return_function_and_argument STR_VAR input= ~%entry%~ RET item=function properties=argument END
          WHILE ~%properties%~ STRING_COMPARE ~~ BEGIN
            LPF return_first_entry STR_VAR list= ~%properties%~ separator = "," RET arg_entry=entry properties=list END
            LPF return_first_letter STR_VAR input= ~%arg_entry%~ RET firstletter=firstletter rest=rest END
            PATCH_IF ~%firstletter%~ STRING_EQUAL_CASE "X" BEGIN // it's numeric
                SET entrynumber=1
                WHILE ~%rest%~ STRING_COMPARE_CASE ~~ BEGIN
                   LPF return_first_entry STR_VAR list= ~%rest%~ separator = "\." RET entry=entry rest=list END
                   SET  ~num%entrynumber%~= ~%entry%~
                   SET entrynumber=entrynumber+1
                END
            END ELSE BEGIN
                PATCH_IF "%arg_entry%" STRING_EQUAL_CASE notequip BEGIN
                   SET equip=0
                END ELSE BEGIN
                   // it's a slot
                   TO_UPPER ~arg_entry~
                   SPRINT ~slot~ ~%arg_entry%~
                END
            END
          END
          PATCH_IF ~%slot%~ STRING_EQUAL_CASE ~NONE~ BEGIN
                INNER_ACTION BEGIN
                   ACTION_IF FILE_EXISTS_IN_GAME ~%item%.itm~ BEGIN
                        COPY_EXISTING ~%item%.itm~ ~override~
                                      SPRINT ~ITM_file~ ~%SOURCE_RES%~
                                      TO_LOWER ~ITM_file~
                                      READ_SHORT 0x1c item_type_code
                                      PATCH_IF VARIABLE_IS_SET $item_location_map(~%item_type_code%~) BEGIN
                                               SPRINT ~slot~ $item_location_map(~%item_type_code%~)
                                               TO_UPPER ~slot~
                                      END ELSE BEGIN
                                               SPRINT ~slot~ INV
                                      END
                        BUT_ONLY
                   END ELSE BEGIN
                        LAF warning STR_VAR warning= "Warning: tried to add item %item%, but it doesn't (yet) exist and you haven't told me its slot" END
                   END
                END
          END
          PATCH_IF ~%slot%~ STRING_COMPARE_CASE ~NONE~ BEGIN
           PATCH_IF ~%slot%~ STRING_EQUAL_CASE ~two-handed~ BEGIN
             SPRINT ~slot~ ~WEAPON~
             SET twohanded=1
           END
           PATCH_IF replace BEGIN
              SPRINT string ~REPLACE_CRE_ITEM~
           END ELSE BEGIN
              SPRINT string ~ADD_CRE_ITEM~
           END
           SPRINT ~string~ ~%string% %item% #%num1% #%num2% #%num3% NONE %slot%~
           PATCH_IF ~%slot%~ STRING_EQUAL_CASE ~WEAPON~ BEGIN
             PATCH_IF equip BEGIN
                 SPRINT ~string~ ~%string% EQUIP~
             END
             PATCH_IF twohanded=1 BEGIN
                SPRINT ~string~ ~%string% TWOHANDED~
             END
           END
           LPF patch_reinclude_this STR_VAR input= ~%string%~ END
          END

       END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_add_items") ""


DEFINE_PATCH_FUNCTION CRE_replace_items
       STR_VAR arguments=""
BEGIN
   LPF CRE_add_items INT_VAR replace=1 STR_VAR arguments END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_replace_items") ""


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////// remove items - just a hook for extant code
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_remove_items
        STR_VAR arguments=""
BEGIN
        PATCH_IF ~%arguments%~ STRING_EQUAL_CASE ~all~ BEGIN
           SPRINT ~temp~ ~REMOVE_CRE_ITEMS~
        END ELSE BEGIN
           SPRINT ~temp~ ~REMOVE_CRE_ITEM %arguments%~
        END
        LPF patch_reinclude_this STR_VAR input= ~%temp%~ END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_remove_items") ""




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////// build a basic creature
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_build
BEGIN
   ///// basic structure
   DELETE_BYTES 0x0 BUFFER_LENGTH
   INSERT_BYTES 0x0 0x434

   // sig
   WRITE_ASCII 0x0 ~CRE V1.0~
  // name
   WRITE_LONG 0x8 ~-1~
   WRITE_LONG 0xc ~-1~
   // hit points
   WRITE_SHORT 0x24 0xff
   WRITE_SHORT 0x24 0xff
   // animation
   WRITE_SHORT 0x28 0xffff
   // effect flag
   WRITE_BYTE 0x33 1
   // portrait
   WRITE_ASCII 0x34 None
   WRITE_ASCII 0x3c None
   // AC
   WRITE_SHORT 0x46 10
   WRITE_SHORT 0x48 10
   // THAC0
   WRITE_BYTE 0x52 100
   // #at
   WRITE_BYTE 0x53 1
   // saves
   WRITE_BYTE 0x54 100
   WRITE_BYTE 0x55 100
   WRITE_BYTE 0x56 100
   WRITE_BYTE 0x57 100
   WRITE_BYTE 0x58 100
   SET sound_loc=0xa4
   WHILE sound_loc < 0x234 BEGIN
      WRITE_LONG sound_loc ~-1~
      SET sound_loc = sound_loc +4
   END
   // level
   WRITE_BYTE 0x234 1
   WRITE_BYTE 0x235 1
   WRITE_BYTE 0x236 1
   // sex
   WRITE_BYTE 0x237 1
   // abilities
   WRITE_BYTE 0x238 9
   WRITE_BYTE 0x23a 9
   WRITE_BYTE 0x23b 9
   WRITE_BYTE 0x23c 9
   WRITE_BYTE 0x23d 9
   WRITE_BYTE 0x23e 9
   // morale [NEEDS RESEARCH]
   WRITE_BYTE 0x23f 10
   WRITE_BYTE 0x240 5
   WRITE_BYTE 0x242 60
   // racial enemy
   WRITE_BYTE 0x241 0xff
   // EA
   WRITE_BYTE 0x270 128
   // general
   WRITE_BYTE 0x271 1
   // race
   WRITE_BYTE 0x272 1
   // class
   WRITE_BYTE 0x273 0xff
   // gender
   WRITE_BYTE 0x275 1
   // alignment
   WRITE_BYTE 0x27b 34
   // probably needs this value
   WRITE_SHORT 0x27c 0xffff
   WRITE_SHORT 0x27e 0xffff
   ////
   //offsets
   WRITE_LONG 0x2a0 0x2d4
   WRITE_LONG 0x2a8 0x2d4
   WRITE_LONG 0x2ac 17
   WRITE_LONG 0x2b0 0x3e4
   WRITE_LONG 0x2b8 0x3e4
   WRITE_LONG 0x2bc 0x3e4
   WRITE_LONG 0x2c4 0x3e4
  //memorization data
   //priest
   FOR(level=0;level<7;level=level+1) BEGIN
     WRITE_SHORT level* 0x10 + 0x2d4 ~level~
   END
 // wizard
   FOR(level=0;level<9;level=level+1) BEGIN
      WRITE_SHORT level* 0x10 + 0x344 ~level~
      WRITE_SHORT 0x6 + level* 0x10 + 0x344 1
   END
   // innate
   WRITE_SHORT 0x3da 2
    // item slot wipe
   FOR (i=0x3e4;i<0x430;i=i+2) BEGIN
      WRITE_SHORT i ~-1~
   END

END

DEFINE_PATCH_FUNCTION CRE_postbuild
BEGIN
   LPF CRE_enforce_saves STR_VAR arguments=only_if_new END
   LPF CRE_enforce_thac0 STR_VAR arguments=only_if_new END
   LPF CRE_enforce_animation STR_VAR arguments=only_if_new END


END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              find the current value of a proficiency
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_read_proficiency
          STR_VAR arguments=""
          RET value
BEGIN
         SET value=0
         TO_UPPER arguments
         SPRINT prof ~PROFICIENCY%arguments%~
         SET prof_int_target=IDS_OF_SYMBOL (~stats~ ~%prof%~)
         SPRINT entry_type effect
         SPRINT file_ext CRE
         LAUNCH_PATCH_MACRO get_offset_array
         SET prof=0
         PHP_EACH offset_array AS int =>offset_base BEGIN
            LPF CRE_read_opcode INT_VAR offset_base= ~%offset_base%~ RET opcode=value END
            PATCH_IF opcode=233 BEGIN
               LPF CRE_read_parameter2 INT_VAR offset_base= ~%offset_base%~ RET prof_int=value END
               PATCH_IF prof_int=prof_int_target BEGIN
                  LPF CRE_read_parameter1 INT_VAR offset_base= ~%offset_base%~ RET value=value END
               END
            END
         END

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              add a proficiency (by name)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_add_proficiencies
          STR_VAR arguments=""
BEGIN
           PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
             LPF return_first_pair STR_VAR list= ~%arguments%~ RET prof=key add=value arguments=list END
             LPF CRE_read_proficiency STR_VAR arguments= ~%prof%~ RET old_value=value END
             TO_UPPER prof
             SET_BG2_PROFICIENCY ~PROFICIENCY%prof%~ old_value+add
             LPF CRE_add_proficiencies STR_VAR arguments= ~%arguments%~ END
           END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_add_proficiencies") ""

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              set a proficiency
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_set_proficiencies
          STR_VAR arguments=""
BEGIN
         PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
             LPF return_first_pair STR_VAR list= ~%arguments%~ RET prof=key set=value arguments=list END
             TO_UPPER prof
             SET_BG2_PROFICIENCY ~PROFICIENCY%prof%~ set
             LPF CRE_set_proficiencies STR_VAR arguments= ~%arguments%~ END
         END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_set_proficiencies") ""


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              wipe existing proficiencies (BG1 and BG2)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_wipe_proficiencies
          STR_VAR arguments=""
BEGIN
            WRITE_ASCII 0x6e ~~ (8)
            LPF CRE_delete_opcodes STR_VAR arguments=233 END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              swap an item
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_swap_items
          STR_VAR arguments=""
BEGIN
         PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
             LPF return_first_pair STR_VAR list= ~%arguments%~ RET old=key new=value arguments=list END
             REPLACE_TEXTUALLY CASE_INSENSITIVE ~%old%~ ~%new%~ (8)
             LPF CRE_swap_items STR_VAR arguments= ~%arguments%~ END
         END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_swap_items") ""

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              delete specified effects
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_delete_opcodes
          STR_VAR arguments=""
BEGIN
         PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
            LPF return_first_entry STR_VAR list= ~%arguments%~ RET opcode_to_delete=entry arguments=list END
            LPF DELETE_CRE_EFFECT INT_VAR opcode_to_delete END
            LPF CRE_delete_opcodes STR_VAR arguments END
         END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_delete_opcodes") ""

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              PC detector  (assumes a PC grid already read in)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_is_PC
        STR_VAR filename=""
        RET value
BEGIN
        LPF CRE_read_dv RET dv=value END
        TO_LOWER dv
        PATCH_IF VARIABLE_IS_SET $script_name_pdialog( ~%dv%~) BEGIN
           PATCH_MATCH "%filename%" WITH
              sarev1 sarevo sarevo2 // BG1 sarevok in EET, shares DV with joinable sarevok
              "%tutu_var%arkani3" "%tutu_var%deder3" // false positives - all copies of the illusionary Candlekeep NPCs who exist in RL as INNOCENTs
              finimoen // false positive, Imoen in Ascension
           BEGIN
              SET value=0
           END
           DEFAULT
              SET value=1
           END
        END ELSE BEGIN
           PATCH_IF ~%filename%~ STRING_EQUAL_CASE ~charbase~ BEGIN
              SET value=1
           END ELSE BEGIN
              SET value=0
           END
        END

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              warrior detector
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_is_warrior
        STR_VAR class=UNKNOWN
        RET value
BEGIN
        PATCH_IF ~%class%~ STRING_EQUAL_CASE UNKNOWN BEGIN
            LPF CRE_read_class RET class=value END
        END
        PATCH_MATCH ~%class%~ WITH
           FIGHTER PALADIN RANGER FIGHTER_MAGE FIGHTER_CLERIC FIGHTER_THIEF FIGHTER_DRUID FIGHTER_MAGE_CLERIC FIGHTER_MAGE_THIEF
        BEGIN
           SET value=1
        END
        DEFAULT
           SET value=0
        END
END
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////             thief detector
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_is_thief
        RET value
BEGIN
        LPF CRE_read_class RET class=value END
        PATCH_MATCH ~%class%~ WITH
           THIEF CLERIC_THIEF MAGE_THIEF FIGHTER_THIEF FIGHTER_MAGE_THIEF
        BEGIN
           SET value=1
        END
        DEFAULT
           SET value=0
        END
END
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////             innocence detector
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_is_innocent
        RET value
BEGIN
        LPF CRE_read_class RET class=value END
        PATCH_MATCH ~%class%~ WITH
           INNOCENT
        BEGIN
           SET value=1
        END
        DEFAULT
           SET value=0
        END
END

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////             alignment detectors
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_is_evil
        RET value
BEGIN
        LPF CRE_read_alignment RET alignment=value END
        PATCH_MATCH ~%alignment%~ WITH
           LAWFUL_EVIL CHAOTIC_EVIL NEUTRAL_EVIL
        BEGIN
           SET value=1
        END
        DEFAULT
           SET value=0
        END
END

DEFINE_PATCH_FUNCTION CRE_is_good
        RET value
BEGIN
        LPF CRE_read_alignment RET alignment=value END
        PATCH_MATCH ~%alignment%~ WITH
           LAWFUL_GOOD CHAOTIC_GOOD NEUTRAL_GOOD
        BEGIN
           SET value=1
        END
        DEFAULT
           SET value=0
        END
END
DEFINE_PATCH_FUNCTION CRE_is_lawful
        RET value
BEGIN
        LPF CRE_read_alignment RET alignment=value END
        PATCH_MATCH ~%alignment%~ WITH
           LAWFUL_GOOD LAWFUL_NEUTRAL LAWFUL_EVIL
        BEGIN
           SET value=1
        END
        DEFAULT
           SET value=0
        END
END
DEFINE_PATCH_FUNCTION CRE_is_chaotic
        RET value
BEGIN
        LPF CRE_read_alignment RET alignment=value END
        PATCH_MATCH ~%alignment%~ WITH
           CHAOTIC_GOOD CHAOTIC_NEUTRAL CHAOTIC_EVIL
        BEGIN
           SET value=1
        END
        DEFAULT
           SET value=0
        END
END
DEFINE_PATCH_FUNCTION CRE_is_geneutral
        RET value
BEGIN
        LPF CRE_read_alignment RET alignment=value END
        PATCH_MATCH ~%alignment%~ WITH
           NEUTRAL LAWFUL_NEUTRAL CHAOTIC_NEUTRAL NONE
        BEGIN
           SET value=1
        END
        DEFAULT
           SET value=0
        END
END

DEFINE_PATCH_FUNCTION CRE_is_lcneutral
        RET value
BEGIN
        LPF CRE_read_alignment RET alignment=value END
        PATCH_MATCH ~%alignment%~ WITH
           NEUTRAL NEUTRAL_GOOD NEUTRAL_EVIL NONE
        BEGIN
           SET value=1
        END
        DEFAULT
           SET value=0
        END
END


DEFINE_PATCH_FUNCTION CRE_make_lawful
        RET value
BEGIN
        LPF CRE_read_alignment RET alignment=value END
        PATCH_MATCH ~%alignment%~ WITH
           NEUTRAL CHAOTIC_NEUTRAL NONE
        BEGIN
           LPF CRE_alignment STR_VAR arguments=LAWFUL_NEUTRAL END
        END
           NEUTRAL_GOOD CHAOTIC_GOOD
        BEGIN
           LPF CRE_alignment STR_VAR arguments=LAWFUL_GOOD END
        END
           NEUTRAL_EVIL CHAOTIC_EVIL
        BEGIN
           LPF CRE_alignment STR_VAR arguments=LAWFUL_EVIL END
        END
        DEFAULT
        END
END


DEFINE_PATCH_FUNCTION CRE_make_chaotic
        RET value
BEGIN
        LPF CRE_read_alignment RET alignment=value END
        PATCH_MATCH ~%alignment%~ WITH
           NEUTRAL LAWFUL_NEUTRAL NONE
        BEGIN
           LPF CRE_alignment STR_VAR arguments=CHAOTIC_NEUTRAL END
        END
           NEUTRAL_GOOD LAWFUL_GOOD
        BEGIN
           LPF CRE_alignment STR_VAR arguments=CHAOTIC_GOOD END
        END
           NEUTRAL_EVIL LAWFUL_EVIL
        BEGIN
           LPF CRE_alignment STR_VAR arguments=CHAOTIC_EVIL END
        END
        DEFAULT
        END
END

DEFINE_PATCH_FUNCTION CRE_make_lcneutral
        RET value
BEGIN
        LPF CRE_read_alignment RET alignment=value END
        PATCH_MATCH ~%alignment%~ WITH
           CHAOTIC_NEUTRAL LAWFUL_NEUTRAL NONE
        BEGIN
           LPF CRE_alignment STR_VAR arguments=NEUTRAL END
        END
           CHAOTIC_GOOD LAWFUL_GOOD
        BEGIN
           LPF CRE_alignment STR_VAR arguments=NEUTRAL_GOOD END
        END
           CHAOTIC_EVIL LAWFUL_EVIL
        BEGIN
           LPF CRE_alignment STR_VAR arguments=NEUTRAL_EVIL END
        END
        DEFAULT
        END
END

DEFINE_PATCH_FUNCTION CRE_make_good
        RET value
BEGIN
        LPF CRE_read_alignment RET alignment=value END
        PATCH_MATCH ~%alignment%~ WITH
           NEUTRAL NEUTRAL_EVIL NONE
        BEGIN
           LPF CRE_alignment STR_VAR arguments=NEUTRAL_GOOD END
        END
           CHAOTIC_NEUTRAL CHAOTIC_EVIL
        BEGIN
           LPF CRE_alignment STR_VAR arguments=CHAOTIC_GOOD END
        END
           LAWFUL_NEUTRAL LAWFUL_EVIL
        BEGIN
           LPF CRE_alignment STR_VAR arguments=LAWFUL_GOOD END
        END
        DEFAULT
        END
END

DEFINE_PATCH_FUNCTION CRE_make_evil
        RET value
BEGIN
        LPF CRE_read_alignment RET alignment=value END
        PATCH_MATCH ~%alignment%~ WITH
           NEUTRAL NEUTRAL_GOOD NONE
        BEGIN
           LPF CRE_alignment STR_VAR arguments=NEUTRAL_EVIL END
        END
           CHAOTIC_NEUTRAL CHAOTIC_GOOD
        BEGIN
           LPF CRE_alignment STR_VAR arguments=CHAOTIC_EVIL END
        END
           LAWFUL_NEUTRAL LAWFUL_GOOD
        BEGIN
           LPF CRE_alignment STR_VAR arguments=LAWFUL_EVIL END
        END
        DEFAULT
        END
END
DEFINE_PATCH_FUNCTION CRE_make_geneutral
        RET value
BEGIN
        LPF CRE_read_alignment RET alignment=value END
        PATCH_MATCH ~%alignment%~ WITH
           NEUTRAL_EVIL NEUTRAL_GOOD NONE
        BEGIN
           LPF CRE_alignment STR_VAR arguments=NEUTRAL END
        END
           CHAOTIC_EVIL CHAOTIC_GOOD
        BEGIN
           LPF CRE_alignment STR_VAR arguments=CHAOTIC_NEUTRAL END
        END
           LAWFUL_EVIL LAWFUL_GOOD
        BEGIN
           LPF CRE_alignment STR_VAR arguments=LAWFUL_NEUTRAL END
        END
        DEFAULT
        END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////             return item in a given slot
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_read_item_in_slot
        STR_VAR arguments=""
        RET value
BEGIN
        PATCH_IF !VARIABLE_IS_SET $item_slot_map(0) BEGIN
           INNER_ACTION BEGIN
              LAUNCH_ACTION_MACRO read_in_item_slots
           END
        END
        TO_UPPER arguments
        SET slot_loc=$item_slot_map(~%arguments%~)
        SET offset_slot=2*slot_loc+LONG_AT $CREoffset_loc(~item_slots~)
        READ_SSHORT offset_slot item_num
        PATCH_IF item_num= ~-1~ BEGIN
          SPRINT value ~~
        END ELSE BEGIN
          SET offset_base=LONG_AT $CREoffset_loc(~item~) + item_num * $CREentry_length(~item~)
          LPF CRE_read_item_resource STR_VAR offset_base RET value=value END
        END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////             check if creature has a given spell
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_has_spell
        STR_VAR arguments=""
        RET value
BEGIN
        SET value=0
        LPF get_spellcode STR_VAR input= ~%arguments%~ RET spell=value END
        SPRINT entry_type memorized_spell
        SPRINT file_ext CRE
        LAUNCH_PATCH_MACRO get_offset_array
        PHP_EACH offset_array AS int=>offset_base BEGIN
           LPF CRE_read_memorized_spell STR_VAR offset_base RET spell_here=value END
           PATCH_IF ~%spell_here%~ STRING_EQUAL_CASE ~%spell%~ BEGIN
              SET value=1
           END
        END
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////             check if creature is dead
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_is_dead
RET value
BEGIN
     LPF CRE_read_state_dead RET value1=value END
     LPF CRE_read_state_stone_death RET value2=value END
     value= (value1 || value2)
END


/////////////////////////////////////////////////////////////////////////////////////////////
///        Returns 1 if creature is unintelligent
/////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_check_if_moron  // non-morons, by definition, are non-zombies, non-golems, non-gibberlings, and in one of the following categories: (i) general=HUMANOID,GIANTHUMANOID, or UNDEAD; (ii) race=DEMONIC, BEHOLDER or LYCANTHROPE; (iii) class=WOLF_VAMPIRIC, DOPPLEGANGER, or DRAGON
      RET value
BEGIN
      LPF CRE_read_race RET race=value END
      TO_UPPER race
      PATCH_MATCH ~%race%~ WITH
      ZOMBIE GIBBERLING BEGIN
         SET value=1
      END
      DEMONIC DOPPLEGANGER LYCANTHROPE BEHOLDER BEGIN
         SET value=0
      END
      DEFAULT
         LPF CRE_read_general RET general=value END
         TO_UPPER general
         PATCH_MATCH ~%general%~ WITH
         HUMANOID GIANTHUMANOID BEGIN
            PATCH_MATCH ~%class%~ WITH
               GOLEM_STONE GOLEM_FLESH GOLEM_CLAY GOLEM_IRON BEGIN
                  SET value=1
               END
               DEFAULT
                  SET value=0
               END
         END
         UNDEAD BEGIN
               PATCH_IF (~%class%~ STRING_EQUAL SKELETON) BEGIN
                  SET value=1
               END ELSE BEGIN
                  SET value=0
               END
         END
         DEFAULT
            LPF CRE_read_class RET class=value END
            TO_UPPER class
            PATCH_MATCH ~%class%~ WITH
            DRAGON DOPPLEGANGER WOLF_VAMPIRIC BEGIN
               SET value=0
            END
            DEFAULT
               SET value=1
            END
         END
      END
END


/////////////////////////////////////////////////////////////////////////////////////////////
///        logs the name of the creature
/////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION CRE_log_me STR_VAR filename="" arguments="" BEGIN
   LPF log_this STR_VAR file= ~%arguments%~ input= ~%filename%~ repeat=no END
END

////////////////////////////////////////////////////////////////////////////////////////////
///        find the highest spell level memorised
/////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_find_highest_spell_level
STR_VAR arguments=mage
RET value
BEGIN
   SET value=0
   SPRINT file_ext CRE
   SPRINT entry_type memorization_info
   LAUNCH_PATCH_MACRO get_offset_array
   PHP_EACH offset_array AS int=>offset_base BEGIN
        READ_SHORT offset_base level
        READ_SHORT offset_base+0xc number
        READ_SHORT offset_base+0x6 type
        PATCH_IF number>0 BEGIN
           SET true_level=level+1
           PATCH_IF true_level>value BEGIN
              PATCH_IF ((~%arguments%~ STRING_EQUAL_CASE mage && type=1) || (~%arguments%~ STRING_EQUAL_CASE priest && type=0)) BEGIN
                 SET value=true_level
              END
           END
        END
   END

END
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////             set the name
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_set_name
   STR_VAR arguments=""
BEGIN
   LPF patch_text_entry STR_VAR function=set_string loc=0xc arguments= ~%arguments%~ END
END

DEFINE_PATCH_FUNCTION CRE_set_unidentified_name
   STR_VAR arguments=""
BEGIN
   LPF patch_text_entry STR_VAR function=set_string loc=0x8 arguments= ~%arguments%~ END
END
DEFINE_PATCH_FUNCTION CRE_say_name
   STR_VAR arguments=""
BEGIN
   LPF say_this_here INT_VAR offset=0x8 say= ~%arguments%~ END
END
DEFINE_PATCH_FUNCTION CRE_say_unidentified_name
   STR_VAR arguments=""
BEGIN
   LPF say_this_here INT_VAR offset=0xc say= ~%arguments%~ END
END

DEFINE_PATCH_FUNCTION CRE_set_both_names
   STR_VAR arguments=""
BEGIN
   LPF CRE_set_name STR_VAR arguments END
   LPF CRE_set_unidentified_name STR_VAR arguments END
END

DEFINE_PATCH_FUNCTION CRE_say_both_names
   STR_VAR arguments=""
BEGIN
   LPF CRE_say_name STR_VAR arguments END
   LPF CRE_say_unidentified_name STR_VAR arguments END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
///       make casting innate
/////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_make_casting_innate
STR_VAR arguments=""
BEGIN
    PATCH_MATCH "%arguments%" WITH
    null BEGIN
         SET value=1
    END
    never BEGIN
         SET value=0
    END
    DEFAULT
         LPF check_label STR_VAR label="%arguments%" RET value=value END
    END
    PATCH_IF value BEGIN
      LPF CRE_immunity_to_opcode STR_VAR file_ext=CRE arguments="38 60 80" END
    END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
///       make casting instant
/////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_make_casting_instant
STR_VAR arguments=""
BEGIN
    PATCH_MATCH "%arguments%" WITH
    null BEGIN
         SET value=1
    END
    never BEGIN
         SET value=0
    END
    DEFAULT
         LPF check_label STR_VAR label="%arguments%" RET value=value END
    END
    PATCH_IF value BEGIN
      LPF CRE_delete_opcodes STR_VAR file_ext=CRE arguments=189 END
      LPF add_entry_inline STR_VAR file_ext=CRE type=effect arguments=~opcode=>189 parameter1=>10~ END
    END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
///       immunity to various elemental and other effects
/////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_immunity
STR_VAR arguments=""
BEGIN
   PATCH_MATCH ~%arguments%~ WITH
    FIRE fire BEGIN
        LPF CRE_immunity_to_spell STR_VAR arguments=~%WIZARD_METEOR_SWARM% %WIZARD_INCENDIARY_CLOUD% %CLERIC_FIRE_STORM% %WIZARD_FIREBALL% %WIZARD_DELAYED_BLAST_FIREBALL% %DEATHKNIGHT_FIREBALL% %WIZARD_SUN_FIRE%~ END
        PATCH_IF is_bg2 BEGIN
           LPF CRE_immunity_to_spell STR_VAR arguments="%RED_DRAGON_HIT%" END
        END
        LPF CRE_resist_fire STR_VAR arguments=100 END
    END
    COLD cold BEGIN
        LPF CRE_immunity_to_spell STR_VAR arguments=~%WIZARD_ICE_STORM% %WIZARD_CONE_OF_COLD%~ END
        PATCH_IF iwd_arcane BEGIN
           LPF CRE_immunity_to_spell STR_VAR arguments="%WIZARD_SNILLOCS_SNOWBALL_SWARM% %WIZARD_ICELANCE% %WIZARD_OTILUKES_FREEZING_SPHERE%" END
        END
        PATCH_IF is_iwd BEGIN
             LPF CRE_immunity_to_spell STR_VAR arguments="%INNATE_DRAGON_BREATH%" END
        END
        PATCH_IF is_bg2 BEGIN
           LPF CRE_immunity_to_spell STR_VAR arguments="%SILVER_DRAGON_BREATH_COLD%" END
        END
        LPF CRE_resist_cold STR_VAR arguments=100 END
    END
    ACID acid BEGIN
        LPF CRE_immunity_to_spell STR_VAR arguments=~%WIZARD_DEATH_FOG%~ END
        LPF CRE_resist_acid STR_VAR arguments=100 END
    END
    ELECTRICITY LIGHTNING electricity lightning BEGIN
        LPF CRE_immunity_to_spell STR_VAR arguments=~%WIZARD_LIGHTNING_BOLT% %WIZARD_CHAIN_LIGHTNING% %CLERIC_CALL_LIGHTNING%~ END
        PATCH_IF is_bg2 BEGIN
           LPF CRE_immunity_to_spell STR_VAR arguments="%BLUE_DRAGON_BREATH%" END
        END
        LPF CRE_resist_electricity STR_VAR arguments=100 END
    END
    INSECTS insects INSECT insect BEGIN
        LPF CRE_immunity_to_spell STR_VAR arguments=~%CLERIC_SUMMON_INSECTS% %CLERIC_INSECT_PLAGUE% %CLERIC_CREEPING_DOOM%~ END
        PATCH_IF is_bg2 BEGIN
           LPF CRE_immunity_to_spell STR_VAR arguments="%BLACK_DRAGON_INSECT%" END
        END
    END
    POISON poison BEGIN
       LPF CRE_immunity_to_spell STR_VAR arguments=~%CLERIC_POISON% %WIZARD_CLOUDKILL%~ END
       LPF CRE_immunity_to_opcode STR_VAR arguments=25 END
        PATCH_IF is_bg2 BEGIN
           LPF CRE_immunity_to_spell STR_VAR arguments="%GREEN_DRAGON_BREATH%" END
        END

       LPF add_entry_inline STR_VAR arguments=~opcode=>173 parameter1=>100~ type=effect file_ext=CRE END
    END
    leveldrain level_drain energydrain energy_drain BEGIN
       LPF CRE_immunity_to_opcode STR_VAR arguments=216 END
       LPF CRE_immunity_to_icon STR_VAR arguments=59 END
       LPF CRE_immunity_to_string STR_VAR arguments="41495 40968 40969 40979 41616" END
    END
	fear FEAR BEGIN
	   LPF CRE_immunity_to_opcode STR_VAR arguments="23 24 106" END
	   LPF CRE_immunity_to_string STR_VAR arguments="14007 17427" END
	   LPF CRE_immunity_to_animation STR_VAR arguments="cdhorror" END
	END
    DEFAULT
       LPF warning STR_VAR warning=~Unrecognised immunity type %arguments% IN CRE_immunity~ END
    END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
///       set level to a particular class only (entry format: "mage=>16 cleric=>14"
///       treat sorcerer as a sort of mage, use priest as shorthand for cleric or druid
/////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION CRE_level_by_class
   STR_VAR arguments=""
BEGIN
   PATCH_IF "%arguments%" STRING_COMPARE_CASE "" BEGIN
      LPF return_first_pair STR_VAR list="%arguments%" RET target_class=key level=value list END
      LPF CRE_read_class RET class=value END
      PATCH_MATCH "%target_class%" WITH
           mage BEGIN
              LPF substitute_string STR_VAR input="%class%" arguments="sorcerer=>mage" RET class=output END
           END
           priest BEGIN
              LPF substitute_string STR_VAR input="%class%" arguments="cleric=>priest druid=>priest" RET class=output END
           END
           DEFAULT
      END
      SET slot=0
      WHILE "%class%" STRING_COMPARE_CASE "" BEGIN
         SET slot+=1
         LPF return_first_entry STR_VAR list="%class%" separator="_" RET class=list entry END
         PATCH_IF "%entry%" STRING_EQUAL_CASE "%target_class%" BEGIN
              LPF "CRE_level%slot%" STR_VAR arguments="%level%" END
         END
      END
      LPF CRE_level_by_class STR_VAR arguments="%list%" END
   END
END
OUTER_SPRINT $SFO_do_not_parse_arguments("CRE_level_by_class") ""



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
///      code to enforce a creature's class features
///
/////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION CRE_enforce_class
   STR_VAR filename=""
           arguments=""
BEGIN
 // argument parsing
 SET even_if_monk=0
 SET joinable=0
 SET read_clab_at_install=0
 WHILE "%arguments%" STRING_COMPARE "" BEGIN
    LPF return_first_entry STR_VAR list="%arguments%" RET entry arguments=list END
    SET "%entry%"=1
 END
 // sanity check - is this an actual class? (or if not, do we have a kit other than MAGESCHOOL_GENERALIST?) Do we have at least one level? If not, skip.
 PATCH_IF (((BYTE_AT 0x273) <30 || ((LONG_AT 0x244) >0 && !(LONG_AT 0x244 = 1073741824))) && (BYTE_AT 0x234)>0 )BEGIN
   // work out the various classes
   LPF CRE_read_class RET classfull=value END
   FOR (i=1;i<=3;i+=1) BEGIN
      SPRINT $class("%i%") "null"
   END
   SET classnum=0
   SPRINT list "%classfull%"
   WHILE "%list%" STRING_COMPARE "" BEGIN
      LPF return_first_entry STR_VAR list separator="_" RET this_class=entry list END
      SET classnum +=1
      PATCH_IF "%this_class%" STRING_EQUAL_CASE monk BEGIN
         PATCH_IF !even_if_monk BEGIN
            SPRINT this_class null
         END
      END
      SPRINT $class("%classnum%") "%this_class%"
      LPF "CRE_read_level%classnum%" RET level=value END
      PATCH_IF level=0 BEGIN
          LPF "CRE_level%classnum%" STR_VAR arguments=1 END
          LPF warning STR_VAR warning="%filename% has a level value of zero for class %this_class%; setting to 1" END
      END
      SET $classlevel("%classnum%")=level
   END
   // check for an original class (only if creature has more than 1 class)
   SPRINT original_class none
   PATCH_IF classnum>1 BEGIN
    LPF CRE_read_original_class RET original_class=value END
    // check if the original class is active
    PATCH_IF "%original_class%" STRING_COMPARE_CASE none BEGIN
      PATCH_IF $class(1) STRING_EQUAL_CASE "%original_class%" BEGIN
         SET original=1
         SET new=2
      END ELSE BEGIN
         SET original=2
         SET new=1
      END
      SET original_level=$classlevel("%original%")
      SET new_level=$classlevel("%new%")
      SPRINT new_class $class("%new%")
      PATCH_IF (original_level >= new_level && "%new_class%" STRING_COMPARE none) BEGIN // class is inactive; from the point of view of this function, anull it
          SPRINT $class("%original%") null
          SPRINT original_class none
          LPF warning STR_VAR warning="%filename%.cre has an inactive class" END
      END
    END
   END
   // sort out memorized spells
   PATCH_IF joinable BEGIN
    FOR (i=1;i<=classnum;i+=1) BEGIN
      SPRINT this_class $class("%i%")
      SET this_level=$classlevel("%i%")
      PATCH_MATCH "%this_class%" WITH
      BARD BEGIN
          SPRINT file mxsplbrd
          SET type=1
      END
      MAGE BEGIN
          SPRINT file mxsplwiz
          SET type=1
      END
      SORCERER SORCEROR BEGIN
        LPF CRE_read_kit RET value END
        PATCH_IF "%value%" STRING_EQUAL_CASE "dragon_disciple" BEGIN
          SPRINT file mxsplsrc
          SET type=1
        END ELSE BEGIN
          SPRINT file mxspldd
          SET type=1
        END
      END
      CLERIC BEGIN
          SPRINT file mxsplprs
          SET type=0
      END
      DRUID BEGIN
          SPRINT file mxspldru
          SET type=0
      END
      PALADIN BEGIN
          SPRINT file mxsplpal
          SET type=0
      END
      RANGER BEGIN
        PATCH_IF "%clasfull%" STRING_COMPARE_CASE "cleric_ranger" BEGIN
          SPRINT file mxsplran
          SET type=0
          SET ind=0
        END ELSE BEGIN
           SPRINT file null
        END
      END
      DEFAULT
          SPRINT file null
      END
      PATCH_IF "%file%" STRING_COMPARE_CASE null BEGIN
         INNER_ACTION BEGIN
            COPY_EXISTING "%file%.2da" "%workspace%"
                 COUNT_2DA_COLS colcount
                 COUNT_2DA_ROWS colcount rowcount
                 SET row=this_level>rowcount? rowcount - 1 : this_level - 1
                 CLEAR_ARRAY spells_per_level
                 FOR (j=0;j+1<colcount;j+=1) BEGIN
                    READ_2DA_ENTRY row j+1 colcount mem_level
                    SET $spells_per_level("%j%")=mem_level
                 END
            BUT_ONLY
         END
         GET_OFFSET_ARRAY mem_off 0x2a8 4 0x2ac 4 0 0 0x10
         PHP_EACH mem_off AS int=>offset BEGIN
            READ_SHORT offset+0x6 this_type
            PATCH_IF type=this_type BEGIN
               READ_SHORT offset lvl
               PATCH_IF VARIABLE_IS_SET $spells_per_level("%lvl%") BEGIN
                  SET temp=$spells_per_level("%lvl%")
                  WRITE_SHORT (0x2 + offset) temp
               END
            END
         END
      END
    END
   END
   // if there is an original class, or if there is only one class, check for a kit
   PATCH_IF "%original_class%" STRING_COMPARE_CASE none || classnum=1 BEGIN
      LPF CRE_read_kit RET kit=value END
      PATCH_MATCH "%kit%" WITH 0 NONE NO_KIT TRUECLASS BEGIN
      END
      DEFAULT
         // find the kit's parent class
         PATCH_IF "%original_class%" STRING_COMPARE_CASE none BEGIN
            FOR (i=1;i<=3;i+=1) BEGIN
               PATCH_IF $class("%i%") STRING_EQUAL_CASE "%original_class%" BEGIN
                  SPRINT $class("%i%") "%kit%"
                  SPRINT original_class "%kit%"
               END
            END
         END ELSE BEGIN // not dual classed, so only class=kit
            PATCH_IF "%class_1%" STRING_COMPARE null BEGIN
               SPRINT $class(1) "%kit%"
            END
         END
      END
   END

   // some hardcoded kit-based item restrictions
   PATCH_MATCH "%kit%" WITH
   kensai BEGIN
    PATCH_FOR_EACH arguments IN gloves armor BEGIN
      LPF CRE_read_item_in_slot STR_VAR arguments RET item=value END
      PATCH_IF ~%item%~ STRING_COMPARE_CASE ~~ BEGIN
              LPF CRE_remove_items STR_VAR arguments= ~%item%~ END
         LPF log_this STR_VAR file=illegal_kensai_gear.txt input= ~%filename% %item%~ END
      END
    END
   END
   BARBARIAN BEGIN
    LPF CRE_read_item_in_slot STR_VAR arguments=armor RET armor=value END
    INNER_PATCH ~%armor%~ BEGIN
      READ_ASCII 0x0 platecheck ELSE ~~(4)
    END
    LPF log_this STR_VAR file=illegal_barbarian_gear.txt input= ~%filename% %armor%~ END
   END
   STALKER BEGIN

   LPF CRE_read_item_in_slot STR_VAR arguments=armor RET armor=value END
   INNER_PATCH ~%armor%~ BEGIN
      READ_ASCII 0x0 check ELSE ~~ (4)
   END
   PATCH_IF (~%check%~ STRING_EQUAL_CASE CHAN || ~%check%~ STRING_EQUAL_CASE PLAT) BEGIN
         LPF log_this STR_VAR file=illegal_stalker_gear.txt input= ~%filename% %armor%~ END
   END

   END
   ARCHER BEGIN
      LPF CRE_read_item_in_slot STR_VAR arguments=armor RET armor=value END
   INNER_PATCH ~%armor%~ BEGIN
      READ_ASCII 0x0 check ELSE ~~ (4)
   END
   PATCH_IF (~%check%~ STRING_EQUAL_CASE CHAN || ~%check%~ STRING_EQUAL_CASE PLAT) BEGIN
         LPF log_this STR_VAR file=illegal_archer_gear.txt input= ~%filename% %armor%~ END
   END
   END
   DEFAULT
   END

   SPRINT deletestring ""
   SPRINT addstring ""
   SPRINT spells ""
   SPRINT spells_known ""


   // enforce the kit

    PATCH_IF (!read_clab_at_install && !joinable) BEGIN
       LPF kit_hardcode INT_VAR level=classlevel_1 STR_VAR kit END
    END ELSE BEGIN
       LPM kit_softcode
    END // end of softcoding

  END // end of sanity check
END


/////////////////////////////////////////
///// Not encapsulated at all, just extracted from enforce_class for readability
/////////////////////////////////////////

DEFINE_PATCH_MACRO kit_softcode BEGIN
   FOR (i=1;i<=classnum;i+=1) BEGIN
     PATCH_IF $class("%i%") STRING_COMPARE "null" BEGIN
       SPRINT kit $class("%i%")
       SET level=$classlevel("%i%")
       INNER_ACTION BEGIN
          // find the CLAB file
          LAF find_clab STR_VAR kit RET clab END
          ACTION_IF FILE_EXISTS_IN_GAME "%clab%.2da"  BEGIN
            COPY_EXISTING "%clab%.2da" "%workspace%"
               COUNT_2DA_COLS colcount
               COUNT_2DA_ROWS colcount rowcount
               FOR (this_level=1;this_level<colcount && this_level <= level; this_level +=1) BEGIN
                  FOR (row=0;row<rowcount;row +=1) BEGIN
                   READ_2DA_ENTRY row this_level colcount entry
                      PATCH_MATCH "%entry%" WITH
                      "GA_.*" BEGIN
                         INNER_PATCH_SAVE spell "%entry%" BEGIN DELETE_BYTES 0x0 3 END
                         TO_LOWER spell
                         PATCH_IF VARIABLE_IS_SET EVALUATE_BUFFER "spells_in_clab_%spell%" BEGIN
                            SET temp=$spells_in_clab("%spell%")
                            SET temp += 1
                            SET $spells_in_clab("%spell%")=temp
                         END ELSE BEGIN
                            SET $spells_in_clab("%spell%")=1
                         END
                      END
                      "AP_.*" BEGIN
                       INNER_PATCH_SAVE spell "%entry%" BEGIN DELETE_BYTES 0x0 3 END
                       TO_UPPER spell

                      PATCH_IF (!enforce_whitelist || "%spell%" STRING_MATCHES_REGEXP "SPCL.*" || VARIABLE_IS_SET $kit_whitelist("%spell%") ) BEGIN
                         PATCH_IF !VARIABLE_IS_SET "RESREF_%spell%_KIT_EFFECTS_ADD" BEGIN
                           SPRINT opcode_drop ""
                           PATCH_FOR_EACH opcode IN 101 142 169 267 BEGIN
                                          SPRINT "%opcode%_sec" ""
                           END
                           SPRINT resource_drop ""
                           SPRINT tempadd ""
                           SPRINT tempremove ""
                           INNER_ACTION BEGIN
                             ACTION_IF FILE_EXISTS_IN_GAME "%spell%.spl" BEGIN
                               COPY_EXISTING "%spell%.spl" "%workspace%"
                                    LPF return_offset STR_VAR entry_type=ability file_ext=SPL RET offset_base=value END
                                    GET_OFFSET_ARRAY2 fx_arr offset_base ITM_V10_HEAD_EFFECTS
                                    PHP_EACH fx_arr AS int=>offset_secondary BEGIN
                                     READ_BYTE offset_secondary+0xc timing
                                     PATCH_IF timing=9 BEGIN                    // we only care about instant/permanent effects
                                       READ_SHORT offset_secondary opcode
                                       READ_LONG offset_secondary+0x4 parameter1
                                       READ_LONG offset_secondary+0x8 parameter2
                                       READ_ASCII offset_secondary+0x14 resource
                                       PATCH_IF "%resource%" STRING_COMPARE "" BEGIN
                                          SPRINT resource_drop "%resource_drop% %resource%"
                                          SPRINT tempadd "%tempadd% add_effect_inline=>~parameter1=>%parameter1%  parameter2=>%parameter2% resource=>%resource% opcode=>%opcode% timing=>9 target=>2~"
                                       END ELSE BEGIN
                                        PATCH_MATCH "%opcode%" WITH
                                        101 142 169 267 BEGIN
                                         SPRINT temp EVALUATE_BUFFER "%%opcode%_sec%"
                                         SPRINT "%opcode%_sec" "%temp% %parameter2%"
                                         SPRINT tempadd "%tempadd% add_effect_inline=>~parameter1=>%parameter1%  parameter2=>%parameter2% resource=>null opcode=>%opcode% timing=>9 target=>2~"
                                        END
                                        DEFAULT
                                         SPRINT tempadd "%tempadd% add_effect_inline=>~parameter1=>%parameter1%  parameter2=>%parameter2% resource=>null opcode=>%opcode% timing=>9 target=>2~"
                                         SPRINT opcode_drop "%opcode_drop% %opcode%"
                                        END
                                       END
                                     END
                                    END
                            BUT_ONLY
                            END // end of ACTION_IF
                         END // end of INNER_ACTION
                         PATCH_IF "%opcode_drop%" STRING_COMPARE_CASE "" BEGIN
                                SPRINT tempremove "delete_effect=>~opcode is_in [%opcode_drop%]~"
                         END
                         PATCH_FOR_EACH opcode IN 101 142 169 267 BEGIN
                                SPRINT list EVALUATE_BUFFER "%%opcode%_sec%"
                                PATCH_IF "%list%" STRING_COMPARE_CASE "" BEGIN
                                     SPRINT tempremove "%tempremove% delete_effect=>~opcode=%opcode% and parameter2 is_in [%list%]~"
                                END
                         END
                         PATCH_IF "%resource_drop%" STRING_COMPARE_CASE "" BEGIN
                                  SPRINT tempremove "%tempremove% delete_effect=>~resource is_in [%resource_drop%]~"
                         END
                         SPRINT "RESREF_%spell%_KIT_EFFECTS_ADD" "%tempadd%"
                         SPRINT "RESREF_%spell%_KIT_EFFECTS_REMOVE" "%tempremove%"
                       END // end of PATCH_IF
                       SPRINT tempremove EVALUATE_BUFFER "%RESREF_%spell%_KIT_EFFECTS_REMOVE%"
                       SPRINT tempadd EVALUATE_BUFFER "%RESREF_%spell%_KIT_EFFECTS_ADD%"
                       SPRINT addstring "%addstring% %tempadd%"
                       PATCH_IF !VARIABLE_IS_SET $AP_already("%spell%") BEGIN
                            PATCH_IF "%tempremove%" STRING_COMPARE "" BEGIN
                                SPRINT deletestring "%deletestring% %tempremove%"
                            END
                            SPRINT $AP_already("%spell%") ""
                       END
                       END
                      END
                      DEFAULT
                      END
                  END
               END
          BUT_ONLY
         END
       END
     END
   END
       PATCH_IF "%deletestring%" STRING_COMPARE_CASE "" BEGIN
          LPF apply_patches_inline STR_VAR file_ext=CRE arguments="%deletestring%" END
       END
       LPF apply_patches_inline STR_VAR file_ext=CRE arguments="%addstring%" END
       SPRINT spells_to_remove ""
       SPRINT spells_to_add ""
       SPRINT spells_known ""
       PHP_EACH spells_in_clab AS key=>value BEGIN
           REMOVE_MEMORIZED_SPELL "%key%"
           SPRINT spells_to_add "%spells_to_add% ~%key%(%value%)~"
           PATCH_IF joinable BEGIN
                 PATCH_IF !VARIABLE_IS_SET $is_innate_spell("%spell%") BEGIN
                            INNER_ACTION BEGIN
                              ACTION_IF FILE_EXISTS_IN_GAME "%spell%.spl" BEGIN
                                   COPY_EXISTING "%spell%.spl" override
                                         READ_SHORT 0x1c type
                                         PATCH_IF type=4 BEGIN
                                            SET $is_innate_spell("%spell%")=1
                                         END ELSE BEGIN
                                            SET $is_innate_spell("%spell%")=0
                                         END
                                   BUT_ONLY
                              END ELSE BEGIN
                                 LAF warning STR_VAR warning="Tried to add kit spell %spell% for kit %kit%, but it doesn't exist" END
                                 OUTER_SET $is_innate_spell("%spell%")=999
                              END
                            END
                 END
                 SET temp=$is_innate_spell("%spell%")
                 PATCH_IF temp=0 BEGIN
                     SPRINT spells_known "%spells_known% ~%key%~"
                 END
           END
       END
       LPF CRE_add_spells STR_VAR arguments="%spells_to_add%" END
    PATCH_IF joinable BEGIN
           LPF CRE_add_known_spells STR_VAR arguments="%spells_known%" END
    END
    PATCH_IF joinable BEGIN
           LPF CRE_add_all_priest_spells END
    END

END


/////////////////////////////////////////
///// Enforce legal ability scores on dual-classing creatures
/////////////////////////////////////////

DEFINE_ACTION_FUNCTION make_dualclass_legal
   STR_VAR original_class=""
           final_class=""
           creature=""
BEGIN
   ACTION_DEFINE_ASSOCIATIVE_ARRAY dual_legal BEGIN
      original=>15
      final=>17
   END
   COPY_EXISTING "%creature%.cre" override
    PHP_EACH dual_legal AS type=>min BEGIN

      SPRINT class EVAL "%%type%_class%"
      PATCH_MATCH "%class%" WITH
      FIGHTER BEGIN
         LPF CRE_strGT STR_VAR arguments="%min%" END
       END
       THIEF BEGIN
         LPF CRE_dexGT STR_VAR arguments="%min%" END
       END
       RANGER BEGIN
         LPF CRE_strGT STR_VAR arguments="%min%" END
         LPF CRE_dexGT STR_VAR arguments="%min%" END
         LPF CRE_conGT STR_VAR arguments="%min%" END
       END
       CLERIC BEGIN
         LPF CRE_wisGT STR_VAR arguments="%min%" END
       END
       MAGE BEGIN
         LPF CRE_intGT STR_VAR arguments="%min%" END
       END
       DRUID BEGIN
         LPF CRE_wisGT STR_VAR arguments="%min%" END
         LPF CRE_chaGT STR_VAR arguments="%min%" END

       END
       DEFAULT END

      END


END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               check that memorised spells are actually used
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION spell_use_script_check
  INT_VAR type=0
  STR_VAR script=""
          log="spells_unused.txt"
          filename=""
BEGIN
   INNER_ACTION BEGIN
      COPY_EXISTING "%script%.bcs" "override"
   END
   PATCH_IF "%filename%" STRING_EQUAL "" BEGIN
      SPRINT filename "%SOURCE_RES%"
   END
   GET_OFFSET_ARRAY spell_array CRE_V10_KNOWN_SPELLS
   PHP_EACH spell_array AS ind=>spell_off BEGIN
      READ_ASCII spell_off spell_resref
      PATCH_MATCH "%spell_resref%" WITH
      "SPPR.*" BEGIN
         SET idscode=1
      END
      "SPWI.*" BEGIN
         SET idscode=2
      END
      "SPIN.*" BEGIN
         SET idscode=3
      END
      "SPCL.*" BEGIN
         SET idscode=4
      END
      DEFAULT
         SET idscode=0
      END
      PATCH_IF type=0 || idscode=0 BEGIN
          SET found=0
      END ELSE BEGIN
          SET found=!(type=idscode)
      END
      PATCH_IF idscode>0 BEGIN
         INNER_PATCH_SAVE res_num "%spell_resref%" BEGIN
            DELETE_BYTES 0x0 4
            INSERT_BYTES 0x0 1
            WRITE_ASCII 0x0 "%idscode%" (1)
         END
         PATCH_IF FILE_CONTAINS "override/%script%.bcs" "%res_num%" BEGIN
            SET found=1
         END
      END ELSE BEGIN
      END
      PATCH_IF !found BEGIN
         PATCH_IF FILE_CONTAINS "override/%script%.bcs" "%spell_resref%" BEGIN
            SET found=1
         END
      END
      PATCH_IF !found BEGIN
         PATCH_IF idscode>0 BEGIN
            LPF NAME_NUM_OF_SPELL_RES STR_VAR spell_res="%spell_resref%" RET spell_name END
            SPRINT input "%filename% %spell_name% (%spell_resref%)"
         END ELSE BEGIN
            SPRINT input "%filename% %spell_resref%"
         END
         LPF log_this STR_VAR file="%log%" input END
      END

   END
END

DEFINE_ACTION_FUNCTION spell_use_script_check_batch
   INT_VAR type=0
   STR_VAR prefix=""
BEGIN
    COPY_EXISTING_REGEXP ".*\.cre" override
       SET match=0
       FOR (offset=0x248;offset<0x270;offset+=8) BEGIN
           READ_ASCII offset script_here
           PATCH_MATCH "%script_here%" WITH
           "%prefix%.*" BEGIN
              SPRINT script "%script_here%"
              SET match=1
           END
           DEFAULT
           END
       END
       PATCH_IF match BEGIN
          LPF spell_use_script_check INT_VAR type STR_VAR script filename="%SOURCE_RES%" END
       END
    BUT_ONLY
END


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Deal with the issue where a file multiply references the same item
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION CRE_deduplicate_items
BEGIN
	abort=0
	READ_LONG 0x2b8 item_slot_off
	CLEAR_ARRAY item_array
	CLEAR_ARRAY slot_item_map
	CLEAR_ARRAY all_items
	CLEAR_ARRAY item_repeated
	FOR (offset=item_slot_off + 0x24; offset<item_slot_off + 0x4a; offset +=2) BEGIN
		READ_SSHORT offset item
		PATCH_IF item>=0 BEGIN
			PATCH_IF VARIABLE_IS_SET $item_array("%item%") BEGIN
				SET $item_array("%item%") +=1
			END ELSE BEGIN
				SET $item_array("%item%") =1
			END
		END	
	END
	GET_OFFSET_ARRAY item_resref_array CRE_V10_ITEMS
	PHP_EACH item_resref_array AS ind=>offset BEGIN
		READ_ASCII offset resref
		TO_LOWER resref
		SPRINT $slot_item_map("%ind%") "%resref%"
		PATCH_IF VARIABLE_IS_SET $all_items("%resref%") BEGIN
			SET $item_repeated("%resref%")=1
		END ELSE BEGIN
			SET $all_items("%resref%")=1
		END
	END
	PHP_EACH item_array AS slot=>num BEGIN
		PATCH_IF num>1 BEGIN
			SPRINT resref $slot_item_map("%slot%")
			PATCH_IF !VARIABLE_IS_SET $item_repeated("%resref%") BEGIN
			 REMOVE_CRE_ITEM "%resref%"
		     FOR (i=0;i<num;i+=1) BEGIN
				ADD_CRE_ITEM "%resref%" #0 #0 #0 ~NONE~ ~INV~
			 END
			END
		END
	END


END


// enforce_xp - Set xp_value based on creature's HD + adjustment

DEFINE_PATCH_FUNCTION CRE_enforce_xp
BEGIN
  LPF fail_unless_int STR_VAR value="%arguments%" expression="" END
  LPF CRE_read_level1 RET level1=value END

  SET level = level1 + arguments
  
  PATCH_MATCH level
  WITH
    1
    BEGIN
      SET xp_value = 15
    END
    2
    BEGIN
      SET xp_value = 35
    END
    3
    BEGIN
      SET xp_value = 65
    END
    4
    BEGIN
      SET xp_value = 120
    END
    5
    BEGIN
      SET xp_value = 175
    END
    6
    BEGIN
      SET xp_value = 270
    END
    7
    BEGIN
      SET xp_value = 420
    END
    8
    BEGIN
      SET xp_value = 650
    END
    9
    BEGIN
      SET xp_value = 975
    END
    10
    BEGIN
      SET xp_value = 1400
    END
    11
    BEGIN
      SET xp_value = 2000
    END
    DEFAULT
    PATCH_IF (level > 11)
    BEGIN
      SET xp_value = (level - 10) * 1000
    END
    ELSE
    BEGIN
      SET xp_value = 7
    END
  END

  LPF CRE_xp_value STR_VAR arguments="%xp_value%" END
END


