//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               compile SSL
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION ~compile_ssl_to_bcs_core~ INT_VAR skip_bcs=0 STR_VAR script="" variables="" booleans="" location="" locbase="" locabs="" rename_to="" inline="" BEGIN
 ACTION_IF !FILE_EXISTS "%workspace%/autolib.slb" BEGIN
     COPY ~.../stratagems-inline/blank~ ~%workspace%\autolib.slb~
 END

     LAF check_ini STR_VAR ini=disable_ssl RET disable_ssl=value END
     ACTION_IF ~%script%~ STRING_EQUAL_CASE ~~ BEGIN
        LAF warning STR_VAR warning="Warning: SSL compilation called with no script" END
     END
     ACTION_TO_LOWER script
     ACTION_TO_LOWER rename_to
     ACTION_IF disable_ssl=0 BEGIN
          ACTION_IF !VARIABLE_IS_SET ~sslvariables~ BEGIN
             OUTER_SPRINT ~sslvariables~ ~~
          END
          ACTION_IF ~%variables%~ STRING_COMPARE_CASE ~~ BEGIN
             ACTION_IF ~%sslvariables%~ STRING_COMPARE_CASE ~~ BEGIN
               OUTER_SPRINT ~sslvariables~ ~%sslvariables%&%variables%~
             END ELSE BEGIN
               OUTER_SPRINT sslvariables ~%variables%~
             END
          END
          ACTION_IF "%booleans%" STRING_COMPARE_CASE "" BEGIN
             OUTER_SPRINT booleanstring "-b %booleans%"
          END ELSE BEGIN
             OUTER_SPRINT booleanstring ""
          END
          ACTION_IF ~%inline%~ STRING_EQUAL yes BEGIN
             COPY ~.../stratagems-inline/%script%.ssl~ ~%workspace%~
             OUTER_SPRINT full_loc ~%workspace%~
          END ELSE BEGIN

             // sanity check
             ACTION_IF FILE_EXISTS ~%scsroot%\%location%\%script%.ssl~ BEGIN
                OUTER_SPRINT full_loc ~%scsroot%\%location%~
             END ELSE BEGIN
                LAF get_directory STR_VAR location locabs locbase RET full_loc=directory END
                ACTION_IF !FILE_EXISTS ~%full_loc%\%script%.ssl~ BEGIN
                   FAIL ~SCS install error: the SSL file %script%.ssl cannot be found at %full_loc%~
                END
             END

          END
          ACTION_IF debug_variable=2 BEGIN
             LAF warning STR_VAR warning= ~SSL call with variables %sslvariables%, library %ssllibrary%, booleans %booleanstring%~ END
             PRINT ~~~~~actual SSL string is ~%scsroot%\%ssl_loc%\ssl.exe %full_loc%\%script% "%sslvariables%" -o %workspace%/ssl_out -l %ssllibrary% %workspace%\autolib %booleanstring%~ ~~~~~
          END
          DELETE "%workspace%/ssl_out/%script%.baf"
          ACTION_IF ~%WEIDU_OS%~ STRING_COMPARE_CASE ~WIN32~ THEN BEGIN
                OUTER_INNER_PATCH_SAVE scsargs "%full_loc%/%script%" BEGIN
                     REPLACE_TEXTUALLY "\" "/"
                END
		AT_NOW ~chmod 755 %scsroot%/%ssl_loc%/ssl.pl~
                AT_NOW ~/usr/bin/perl %scsroot%/%ssl_loc%/ssl.pl %scsargs% "%sslvariables%" -o %workspace%/ssl_out -l %ssllibrary% %workspace%/autolib %booleanstring%~ EXACT	  
          END ELSE BEGIN
                LAF check_ini STR_VAR ini=Use_Perl_Natively RET value END
                ACTION_IF value BEGIN
                   AT_NOW ~perl %scsroot%\%ssl_loc%\ssl.pl %full_loc%\%script% "%sslvariables%" -o %workspace%/ssl_out -l %ssllibrary% %workspace%\autolib %booleanstring%~
		END ELSE BEGIN
                   AT_NOW ~%scsroot%\%ssl_loc%\ssl.exe %full_loc%\%script% "%sslvariables%" -o %workspace%/ssl_out -l %ssllibrary% %workspace%\autolib %booleanstring%~
		END
	  END
	  COPY ~%workspace%\ssl_out\%script%.baf~ ~%workspace%\ssl_out~ EVALUATE_BUFFER
	     PATCH_IF  !enhanced_edition BEGIN
                LPF ssl_ee_to_vanilla END
             END
             LPF implement_line_if END
          BUT_ONLY
	  ACTION_IF skip_bcs=0 BEGIN
	   ACTION_IF ~%rename_to%~ STRING_COMPARE_CASE ~~ BEGIN
	     COPY + ~%workspace%\ssl_out\%script%.baf~ ~%workspace%\ssl_out\%rename_to%.baf~ 
             COMPILE EVALUATE_BUFFER ~%workspace%\ssl_out\%rename_to%.baf~
           END ELSE BEGIN
             COMPILE EVALUATE_BUFFER ~%workspace%\ssl_out\%script%.baf~
           END
          END
     END ELSE BEGIN
        LAF warning STR_VAR warning="Warning: SSL compilation disabled" END
     END
END

DEFINE_ACTION_FUNCTION ~ssl_to_bcs~
         STR_VAR script="" location="" locbase="" locabs="" variables="" booleans="" rename_to="" inline=""
BEGIN
         // "location" should in normal circumstances be relativised to local_loc, but SSL permits
         // it to be relative to scsroot (for legacy reasons)

         ACTION_IF ~%script%~ STRING_EQUAL ~~ BEGIN
               LAF warning STR_VAR warning="Warning: SSL compiler called with empty argument" END
         END
         OUTER_WHILE ~%script%~ STRING_COMPARE ~~ BEGIN
               LAF return_first_entry STR_VAR list=~%script%~ RET script=list script_to_call=entry END
               LAF compile_ssl_to_bcs_core STR_VAR script=~%script_to_call%~ location locbase locabs variables booleans rename_to inline END
         END

END

DEFINE_ACTION_FUNCTION ~ssl_to_baf~
         STR_VAR script="" location="" locbase="" locabs="" variables="" inline=""  booleans=""
BEGIN
         ACTION_IF ~%script%~ STRING_EQUAL ~~ BEGIN
               LAF warning STR_VAR warning="Warning: SSL compiler called with empty argument" END
         END
         OUTER_WHILE ~%script%~ STRING_COMPARE ~~ BEGIN
               LAF return_first_entry STR_VAR list= ~%script%~ RET script=list script_to_call=entry END
               LAF compile_ssl_to_bcs_core INT_VAR skip_bcs=1 STR_VAR script=  ~%script_to_call%~ location locbase locabs variables booleans inline  END
         END

END


DEFINE_ACTION_FUNCTION ~COMPILE_SSL_TO_BCS~         STR_VAR script="" location="" variables="" rename_to="" inline="" booleans="" BEGIN   // legacy name
        LAF ssl_to_bcs STR_VAR script location variables rename_to inline booleans END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DEFINE_PATCH_FUNCTION implement_line_if BEGIN
   REPLACE_EVALUATE "LineIf<\([^>]*\)> *<\([^>]*\)>"
   BEGIN
      PATCH_IF IS_AN_INT MATCH2 BEGIN
         PATCH_IF MATCH2 BEGIN
            SPRINT output "%MATCH1%"
         END ELSE BEGIN
            SPRINT output ""
         END
      END ELSE BEGIN
         SPRINT output ""
      END
   END
   "%output%"
END


DEFINE_ACTION_FUNCTION compile_ssl_output // largely for debugging
   STR_VAR script="" 
BEGIN
	  COPY ~%workspace%\ssl_out\%script%.baf~ ~%workspace%\ssl_out~ EVALUATE_BUFFER
	     PATCH_IF  !enhanced_edition BEGIN
                LPF ssl_ee_to_vanilla END
             END
             LPF implement_line_if END
          BUT_ONLY
          COMPILE EVALUATE_BUFFER ~%workspace%\ssl_out\%script%.baf~


END



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               install all the listed files
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION install
       INT_VAR overwrite=1
       STR_VAR file=""
               files=""
               location=""
               locbase=""
               inline="no"
               postfix=""
BEGIN
       ACTION_IF ~%file%~ STRING_EQUAL_CASE ~~ BEGIN
          ACTION_IF ~%files%~ STRING_EQUAL_CASE ~~ BEGIN
              PRINT ~Warning: you've called an install with no argument~
          END ELSE BEGIN
              OUTER_SPRINT file ~%files%~
          END
       END
       PRINT ~Installing file(s) %file%~
       ACTION_IF ~%inline%~ STRING_EQUAL_CASE yes BEGIN
        OUTER_SPRINT file_loc ~.../stratagems-inline~
       END ELSE BEGIN
          LAF get_directory STR_VAR location locbase RET file_loc=directory END
       END
       OUTER_WHILE ~%file%~ STRING_COMPARE ~~ BEGIN
           LAF return_first_entry STR_VAR list= ~%file%~ RET entry file=list END
           ACTION_IF "%entry%" STRING_EQUAL_CASE all BEGIN
              ACTION_IF "%postfix%" STRING_EQUAL "" BEGIN
                 ACTION_BASH_FOR "%file_loc%" ".*" BEGIN
                    OUTER_SPRINT file "%file% %BASH_FOR_FILE%"
                 END
              END ELSE BEGIN
                 ACTION_BASH_FOR "%file_loc%" ".*\.%postfix%" BEGIN
                    OUTER_SPRINT file "%file% %BASH_FOR_RES%"
                 END
              END
           END ELSE BEGIN
            ACTION_IF "%postfix%" STRING_EQUAL "" BEGIN
             OUTER_PATCH_SAVE entry ~%entry%~ BEGIN
              SET postfix_start = INDEX_BUFFER (~\.~) +1
              SET postfix_length = BUFFER_LENGTH - postfix_start
              READ_ASCII postfix_start postfix_here (~postfix_length~)
              DELETE_BYTES (postfix_start - 1) (postfix_length + 1)
             END
             OUTER_SPRINT entry_full "%entry%.%postfix_here%"
            END ELSE BEGIN
               OUTER_SPRINT entry_full "%entry%.%postfix%"
               OUTER_SPRINT postfix_here "%postfix%"
            END
            ACTION_IF !overwrite BEGIN
               ACTION_MATCH "%postfix_here%" WITH
               baf ssl BEGIN
                  OUTER_SPRINT to_check "%entry%.bcs"
               END
               d BEGIN
                  OUTER_SPRINT to_check "%entry%.dlg"
               END
               DEFAULT
                  OUTER_SPRINT to_check "%entry_full%"
               END
            END
            ACTION_IF (overwrite OR !FILE_EXISTS_IN_GAME "%to_check%") BEGIN
             ACTION_MATCH "%postfix_here%" WITH
             baf d BEGIN
              COMPILE ~%file_loc%/%entry_full%~ EVALUATE_BUFFER
             END
             ssl BEGIN
              LAF ssl_to_bcs STR_VAR script="%entry%" location END
             END
             cre BEGIN
              COPY ~%file_loc%/%entry_full%~ ~override~
                  LPF FJ_CRE_EFF_V2 END
             END
             DEFAULT
              COPY ~%file_loc%/%entry_full%~ ~override~
             END
            END ELSE BEGIN
                   PRINT "Not installing %entry_full% as it is already present"
            END
           END
       END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               Extend a script
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION extend
         INT_VAR tv=0
                 allow_missing=0
         STR_VAR file=""
                 files=""
                 script=""
                 top=""
                 bottom=""
                 location=""
                 locbase=""
                 locabs=""
                 inline="no"
                 ssl="no"
                 variables=""
BEGIN
       ACTION_IF ~%file%%files%%script%~ STRING_EQUAL_CASE ~~ BEGIN
              PRINT ~Warning: you've called an extend with no main file~
          END ELSE BEGIN
              OUTER_SPRINT file ~%file%%files%%script%~
       END
       ACTION_IF ~%ssl%~ STRING_EQUAL_CASE yes BEGIN
         ACTION_FOR_EACH script IN ~%top%~ ~%bottom%~ BEGIN
         ACTION_IF ~%script%~ STRING_COMPARE_CASE ~~ BEGIN
            LAF ssl_to_baf STR_VAR script location variables inline END
         END
        END
        OUTER_SPRINT file_loc ~%workspace%\ssl_out~
       END ELSE BEGIN
           ACTION_IF ~%inline%~ STRING_EQUAL_CASE yes BEGIN
               OUTER_SPRINT file_loc ~.../stratagems-inline~
           END ELSE BEGIN
               LAF get_directory STR_VAR location locbase locabs RET file_loc=directory END
           END
       END
       OUTER_WHILE ~%file%~ STRING_COMPARE ~~ BEGIN
           LAF return_first_entry STR_VAR list= ~%file%~ RET entry file=list END
           ACTION_IF tv BEGIN
              OUTER_SPRINT entry ~%tutu_var%%entry%~
           END
           ACTION_IF ~%top%~ STRING_COMPARE_CASE ~~ BEGIN
              EXTEND_TOP ~%entry%.bcs~ ~%file_loc%/%top%.baf~ EVALUATE_BUFFER
           END
           ACTION_IF ~%bottom%~ STRING_COMPARE_CASE ~~ BEGIN
              EXTEND_BOTTOM ~%entry%.bcs~ ~%file_loc%/%bottom%.baf~ EVALUATE_BUFFER
           END
       END


END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               Compile a script under a different name (syntax is oldname=>newname)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION compile_rename
STR_VAR file=""
        files=""
        location=""
        locbase=""
BEGIN
       ACTION_IF ~%file%~ STRING_EQUAL_CASE ~~ BEGIN
          ACTION_IF ~%files%~ STRING_EQUAL_CASE ~~ BEGIN
              PRINT ~Warning: you've called a compile_rename with no main file~
          END ELSE BEGIN
              OUTER_SPRINT file ~%files%~
          END
       END
       LAF get_directory STR_VAR location locbase RET file_loc=directory END
       OUTER_WHILE ~%file%~ STRING_COMPARE ~~ BEGIN
          LAF return_first_pair STR_VAR list= ~%file%~ RET oldscript=key newscript=value file=list END
          COPY ~%file_loc%\%oldscript%.baf~ ~%workspace%\%newscript%.baf~
          COMPILE EVALUATE_BUFFER ~%workspace%\%newscript%.baf~
       END

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               Clone a script A=>B and then extend it with another script also called B
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION clone_extend
       STR_VAR arguments=""
               top="yes"
               location=""
               locbase=""
               inline="no"
BEGIN
       ACTION_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
          LAF return_first_pair STR_VAR list= ~%arguments%~ RET source=key script=value arguments=list END
          COPY_EXISTING ~%source%.bcs~ ~override/%script%.bcs~
          ACTION_IF ~%top%~ STRING_EQUAL_CASE ~no~ BEGIN
               LAF extend STR_VAR files= ~%script%~ location locbase inline bottom= ~%script%~ END
          END ELSE BEGIN
               LAF extend STR_VAR files= ~%script%~ location locbase inline top= ~%script%~ END
          END
          LAF clone_extend STR_VAR arguments top location inline END
       END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               merge two scripts
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_ACTION_FUNCTION merge_scripts
   STR_VAR top=""
           bottom=""
           script=""
BEGIN
   COPY_EXISTING "%bottom%.bcs" "%workspace%/%bottom%.baf"
      DECOMPILE_BCS_TO_BAF
   COPY_EXISTING "%top%.bcs" "override/%script%.bcs"
      DECOMPILE_BCS_TO_BAF
      APPEND_FILE TEXT "%workspace%/%bottom%.baf"
      COMPILE_BAF_TO_BCS

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               make a textual substitution
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



DEFINE_PATCH_FUNCTION swap_text_core
     STR_VAR arguments=""
BEGIN
     PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
        LPF return_first_pair STR_VAR list= ~%arguments%~ RET arguments=list old=key new=value END
        PATCH_IF ~%new%~ STRING_EQUAL_CASE ~NULL~ BEGIN
           SPRINT ~new~ ~~
        END
        REPLACE_TEXTUALLY CASE_INSENSITIVE ~%old%~ ~%new%~
        LPF swap_text_core STR_VAR arguments= ~%arguments%~ END
     END
END

DEFINE_PATCH_FUNCTION swap_text_core2
     STR_VAR arguments=""
BEGIN
     PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
        LPF return_first_pair STR_VAR list= ~%arguments%~ RET arguments=list old=key new=value END
        PATCH_IF ~%new%~ STRING_EQUAL_CASE ~NULL~ BEGIN
           SPRINT ~new~ ~~
        END
        SET len1=STRING_LENGTH ~%old%~
        SET len2=STRING_LENGTH ~%new%~
        SET len = len1>len2?len1:len2
        REPLACE_TEXTUALLY CASE_INSENSITIVE ~%old%~ ~%new%~ (len)
        LPF swap_text_core2 STR_VAR arguments= ~%arguments%~ END
     END
END

DEFINE_ACTION_FUNCTION swap_text
    INT_VAR tv=0
            allow_missing=0
    STR_VAR files=""
            file=""
            swaps=""
            postfix=""
BEGIN
    OUTER_SPRINT files "%files%%file%"
    OUTER_WHILE ~%files%~ STRING_COMPARE_CASE ~~ BEGIN
      LAF return_first_entry STR_VAR list= ~%files%~ RET files=list entry=entry END
      ACTION_IF tv BEGIN
            OUTER_SPRINT ~entry~ ~%tutu_var%%entry%~
      END
      ACTION_IF (~%postfix%~ STRING_COMPARE_CASE ~~) BEGIN
            OUTER_SPRINT ~entry~ ~%entry%.%postfix%~
      END
      ACTION_IF (!allow_missing || FILE_EXISTS_IN_GAME ~%entry%~) BEGIN
         OUTER_PATCH ~%entry%~ BEGIN
              SET postfix_start = INDEX_BUFFER (~\.~) +1
              SET postfix_length = BUFFER_LENGTH - postfix_start
              READ_ASCII postfix_start pf (~postfix_length~)
         END
         ACTION_TO_LOWER pf
         ACTION_MATCH "%pf%" WITH
         bcs dlg BEGIN
              COPY_EXISTING ~%entry%~ ~override~
                   DECOMPILE_AND_PATCH BEGIN
                      LPF swap_text_core STR_VAR arguments =  ~%swaps%~ END
                   END
              BUT_ONLY
         END
         2da ids BEGIN
              COPY_EXISTING ~%entry%~ ~override~
                      LPF swap_text_core STR_VAR arguments =  ~%swaps%~ END
              BUT_ONLY
         END
         DEFAULT
              COPY_EXISTING ~%entry%~ ~override~
                      LPF swap_text_core2 STR_VAR arguments =  ~%swaps%~ END
              BUT_ONLY
         END
      END
    END
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               output  the name of the file
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION log_resource_name STR_VAR arguments="SFOlog" filename="" file_ext="" BEGIN


   TO_LOWER file_ext
   PATCH_MATCH ~%file_ext%~ WITH itm BEGIN
      READ_STRREF 0xc name
      SPRINT output ~%filename% %name%~
   END
   cre spl BEGIN
      READ_STRREF 0x8 name
      SPRINT output ~%filename% %name%~
   END
   DEFAULT
      SPRINT output ~%filename%~
   END

   INNER_ACTION BEGIN
   <<<<<<<< log.txt
   >>>>>>>>


      ACTION_IF !FILE_EXISTS ~%workspace%/%arguments%.txt~ BEGIN
         COPY log.txt ~%workspace%/%arguments%.txt~
      END
      APPEND_OUTER ~%workspace%/%arguments%.txt~ ~%output%~
   END

END
OUTER_SPRINT $SFO_do_not_parse_arguments("log_resource_name") ""


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               Say something at an offset
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION say_this_here
      INT_VAR offset=0
              say=0
BEGIN
   SPRINT input ~SAY %offset% %atsymbol%%say%~ // why? for more specific error messages
   PATCH_TRY
      LPF patch_reinclude_this STR_VAR input END
   WITH DEFAULT
      PATCH_PRINT "Failed to SAY %atsymbol%%say% at offset %offset%, most likely because the string does not exist in the TRA file"
      PATCH_RERAISE
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              Get a strref for a tra entry by number
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION strref_of_tra
      INT_VAR  arguments=0
      RET value
BEGIN
   SPRINT input ~SET value=RESOLVE_STR_REF (%atsymbol%%arguments%)~ // why? for more specific error messages
   PATCH_TRY
      LPF patch_reinclude_this STR_VAR input END
   WITH DEFAULT
      PATCH_PRINT "Failed to RESOLVE_STR_REF for %atsymbol%%arguments%, most likely because the string does not exist in the TRA file"
      PATCH_RERAISE
   END
END

DEFINE_ACTION_FUNCTION strref_of_tra
      INT_VAR  arguments=0
      RET value
BEGIN
   OUTER_PATCH "" BEGIN
      LPF strref_of_tra STR_VAR arguments RET value END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               Return the offset of a given entry
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION return_offset
        INT_VAR offset_num=0
        STR_VAR file_ext=""
                entry_type=""
        RET value offset_loc
BEGIN
   PATCH_IF "%file_ext%" STRING_EQUAL_CASE "" BEGIN
      PATCH_FAIL "You need to specify the file extension for return_offset"
   END
   PATCH_IF "%entry_type%" STRING_EQUAL_CASE "" BEGIN
      PATCH_FAIL "You need to specify the entry type for return_offset"
   END
   SET offset_loc=$ ~%file_ext%offset_loc~(~%entry_type%~)
   SET offset_length=$ ~%file_ext%offset_length~(~%entry_type%~) 
   PATCH_MATCH offset_length WITH
   2 BEGIN
      READ_SHORT offset_loc offset_base
   END
   4 BEGIN
      READ_LONG offset_loc offset_base
   END
   DEFAULT
      LPF warning STR_VAR warning="warning: unknown length of offset" END
   END
   SET entry_length=$ ~%file_ext%entry_length~(~%entry_type%~)
   SET value=offset_base + offset_num * entry_length
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               Increment the offset of a given entry
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION increment_offset
        INT_VAR arguments=0
        STR_VAR file_ext=""
                entry_type=""

BEGIN
   PATCH_IF "%file_ext%" STRING_EQUAL_CASE "" BEGIN
      PATCH_FAIL "You need to specify the file extension for increment_offset"
   END
   PATCH_IF "%entry_type%" STRING_EQUAL_CASE "" BEGIN
      PATCH_FAIL "You need to specify the entry type for increment_offset"
   END
   SET offset_loc=$ ~%file_ext%offset_loc~(~%entry_type%~)
   SET offset_length=$ ~%file_ext%offset_length~(~%entry_type%~) 
   PATCH_MATCH offset_length WITH
   2 BEGIN
      WRITE_SHORT offset_loc ((SHORT_AT offset_loc) + arguments)
   END
   4 BEGIN
      WRITE_LONG offset_loc ((LONG_AT offset_loc) + arguments)
   END
   DEFAULT
      LPF warning STR_VAR warning="warning: unknown length of offset" END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               Return the number of a given entry
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION return_number_entries
        STR_VAR file_ext=""
                entry_type=""
        RET value
BEGIN
   PATCH_IF "%file_ext%" STRING_EQUAL_CASE "" BEGIN
      PATCH_FAIL "You need to specify the file extension for return_number_entries"
   END
   PATCH_IF "%entry_type%" STRING_EQUAL_CASE "" BEGIN
      PATCH_FAIL "You need to specify the entry type for return_number_entries"
   END
 SET loc=$ ~%file_ext%entrynum_loc~(~%entry_type%~)
 SET length=$ ~%file_ext%entrynum_length~(~%entry_type%~)
 PATCH_IF loc="-1" BEGIN
          SET value="-1"
 END ELSE BEGIN
   PATCH_MATCH length WITH
   2 BEGIN
      READ_SHORT loc value
   END
   4 BEGIN
      READ_LONG loc value
   END
   0 BEGIN
      SET value="-1"
   END
   DEFAULT
      LPF warning STR_VAR warning="warning: unknown length of offset" END
   END
 END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               Increment the number of a given entry
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION increment_number_entries
        INT_VAR arguments=0
        STR_VAR file_ext=""
                entry_type=""

BEGIN
   PATCH_IF "%file_ext%" STRING_EQUAL_CASE "" BEGIN
      PATCH_FAIL "You need to specify the file extension for increment_number_entries"
   END
   PATCH_IF "%entry_type%" STRING_EQUAL_CASE "" BEGIN
      PATCH_FAIL "You need to specify the entry type for increment_number_entries"
   END
 SET loc=$ ~%file_ext%entrynum_loc~(~%entry_type%~)
 SET length=$ ~%file_ext%entrynum_length~(~%entry_type%~)
 PATCH_IF loc="-1" BEGIN

 END ELSE BEGIN
   PATCH_MATCH length WITH
   2 BEGIN
      WRITE_SHORT loc ((SHORT_AT loc) + arguments)
   END
   4 BEGIN
      WRITE_LONG loc ((LONG_AT loc) + arguments)
   END
   0 BEGIN
   END
   DEFAULT
      LPF warning STR_VAR warning="warning: unknown length of offset" END
   END
 END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              count the files of a given type
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION count_files
      STR_VAR file_ext=""
              tv="no"
      RET value
BEGIN
      ACTION_IF ~%tv%~ STRING_EQUAL_CASE yes BEGIN
         OUTER_SPRINT base ~%tutu_var%~
      END ELSE BEGIN
         OUTER_SPRINT base ~~
      END
      OUTER_SET value=0
      COPY_EXISTING_REGEXP GLOB ~%base%.*\.%file_ext%~ ~override~
            SET value+=1
      BUT_ONLY
END



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              clone a list of scripts
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



DEFINE_ACTION_FUNCTION clone_script
    STR_VAR script=""
BEGIN
   ACTION_IF ~%script%~ STRING_COMPARE_CASE ~~ BEGIN
      LAF return_first_pair STR_VAR list= ~%script%~ RET script=list old=key new=value END
      COPY_EXISTING ~%old%.bcs~ ~override/%new%.bcs~
      LAF clone_script STR_VAR script END
   END
END





////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////      Apply the function "arguments", which in turn takes arguments offset, (NOT offset_base) 
////////////      filename, file_ext, to the offset of every strref in the file.
////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION apply_to_strrefs
          STR_VAR arguments=""
                  filename=""
                  file_ext=""
BEGIN
        TO_LOWER file_ext
        PATCH_MATCH "%file_ext%" WITH
        are BEGIN 
            SPRINT fixed_loc ""
            SPRINT ext_loc "trigger=>0x64 trigger=>0xb8 container=>0x84 door=>0x98 door=>0xb4 mapnote=>0x4"
            // special case: the interruption explanation text
            READ_LONG 0xc0 offset_base
          FOR (i=0;i<10;i+=1) BEGIN
               SET offset=offset_base + i * 0x4 + 0x20
               SPRINT fixed_loc "%fixed_loc% %offset%"
            END
        END
        cre BEGIN
            SPRINT fixed_loc "0x8 0xc"
            SPRINT ext_loc  ""
            // special case: soundset
            FOR (i=0;i<100;i+=1) BEGIN
               SET offset=0xa4 + 0x4 * i
               SPRINT fixed_loc "%fixed_loc% %offset%"
            END
        END
        dlg BEGIN
            SPRINT fixed_loc ""
            SPRINT ext_loc "state=>0x0 transition=>0x4 transition=>0x8"
        END
        itm spl BEGIN
            SPRINT fixed_loc "0x8 0xc 0x50 0x54"
            SPRINT ext_loc ""
            LPF apply_to_strrefs_opcode_helper STR_VAR file_ext RET opcode_loc=opcode_loc END
            SPRINT fixed_loc "%fixed_loc% %opcode_loc%"
        END
        sto BEGIN
            SPRINT fixed_loc "0xc"
            SPRINT ext_loc "drink=>0x8"
        END
        wmp BEGIN
           SPRINT fixed_loc "0x24"
           SPRINT ext_loc "area=>0x40 area=>0x44"
        END
        wav bam vvc pro baf bcs 2da BEGIN
           SPRINT fixed_loc ""
           SPRINT ext_loc ""
        END
        eff BEGIN
           SPRINT fixed_loc ""
           SPRINT ext_loc ""
           LPF warning STR_VAR warning="apply_to_strref has skipped %filename%.eff, which might be a problem in the vanishingly unlikely event it's got a strref in it" END
        END
        DEFAULT
           SPRINT fixed_loc ""
           SPRINT ext_loc ""
           LPF warning STR_VAR warning="apply_to_strref can't patch file %filename%.%file_ext%: filetype not recognised" END
        END
        WHILE "%fixed_loc%" STRING_COMPARE "" BEGIN
           LPF return_first_entry STR_VAR list="%fixed_loc%" RET offset=entry fixed_loc=list END
           LPF "%arguments%" INT_VAR offset  STR_VAR filename file_ext  END
        END
        WHILE "%ext_loc%" STRING_COMPARE "" BEGIN
           LPF return_first_pair STR_VAR list="%ext_loc%" RET entry_type=key offset_ext=value ext_loc=list END
           LPM get_offset_array
           PHP_EACH offset_array AS int=>offset_base BEGIN
                LPF "%arguments%" INT_VAR offset=offset_base+offset_ext STR_VAR filename file_ext  END
           END
        END
END

DEFINE_PATCH_FUNCTION apply_to_strrefs_opcode_helper
        STR_VAR file_ext=""
        RET opcode_loc
BEGIN
        SPRINT opcode_loc ""
        // common
        PATCH_FOR_EACH opcode IN 103 139 180 181 BEGIN
           SPRINT $opcode_has_strref("%opcode%") ""
        END
        // game-specific
        PATCH_IF GAME_IS "iwd how totlm iwd2" BEGIN
            SPRINT $opcode_has_strref("183") ""
        END ELSE
        PATCH_IF GAME_IS "pst" BEGIN
        END ELSE BEGIN // assume it's BG2
           PATCH_FOR_EACH opcode IN 206 253 254 267 290 BEGIN
               SPRINT $opcode_has_strref("%opcode%") ""
           END
        END
        PATCH_IF "%file_ext%" STRING_EQUAL_CASE itm BEGIN
           SET length=0x38
        END ELSE BEGIN
           SET length=0x28
        END
        GET_OFFSET_ARRAY eq_eff ITM_V10_GEN_EFFECTS
        PHP_EACH eq_eff AS int=>offset BEGIN
           READ_SHORT offset opcode
           PATCH_IF VARIABLE_IS_SET $opcode_has_strref("%opcode%") BEGIN
              SET loc_here=offset + 0x4
              SPRINT opcode_loc "%opcode_loc% %loc_here%"
           END
        END
        GET_OFFSET_ARRAY ab_arr 0x64 4 0x68 2 0 0 length
        PHP_EACH ab_arr AS int=>ab_off BEGIN
            GET_OFFSET_ARRAY2 eff_arr ab_off ITM_V10_HEAD_EFFECTS
            PHP_EACH eff_arr AS int=>offset BEGIN
             READ_SHORT offset opcode
             PATCH_IF VARIABLE_IS_SET $opcode_has_strref("%opcode%") BEGIN
              SET loc_here=offset + 0x4
              SPRINT opcode_loc "%opcode_loc% %loc_here%"
             END
            END
        END
END

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////      Apply the function "arguments" to each strref in the file, treated as a plain text
////////////      file containing BAF script. The function takes argument "strref" and must return "strref_new", which is treated as
////////////      the new value of the strref (return the old value if you just want to log it or something)
////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION apply_to_strrefs_script 
   STR_VAR arguments=""
           filename=""
BEGIN
   REPLACE_EVALUATE "DisplayString\([A-Za-z]*\)(\([^,]+\),\([0-9]+\))" BEGIN
        LPF "%arguments%" STR_VAR strref="%MATCH3%" filename  RET strref_new=strref_new  END
   END
   "DisplayString%MATCH1%(%MATCH2%,%strref_new%)"
   REPLACE_EVALUATE "AddJournalEntry(\([0-9]+\)" BEGIN
        LPF "%arguments%" STR_VAR strref="%MATCH1%" filename RET strref_new=strref_new END
   END
   "AddJournalEntry(%strref_new%"
END

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////      Apply the function "arguments" to each strref in the file, treated as a 2da
////////////      file. The function takes argument "strref" and must return "strref_new", which is treated as
////////////      the new value of the strref (return the old value if you just want to log it or something)
////////////
////////////      Note that detection of which numbers in a 2da file are strrefs is of necessity a bit
////////////      heuristic. We assume that 
////////////      - no integer lower than 160 is a strref (the actual values from 1-100 in BG2 are
////////////      dialog strings not referenced in 2das)
////////////      - no integer larger than 299999 is a strref (this is way bigger than any actual dlg)
////////////      - no integer in the following 2das is a strref:
////////////         banttimg clearair extanim extspeed happy pplane raisdead randcolr repmodst splashs2 splashsc startare startbp startpos strmod strmodex xpbonus xpcap xplevel xplist
////////////
////////////      - no integer <10000 in the following is a strref:
////////////      end15fps endmve1 endmve2 endmve3 intro intro15f melissan xnewarea
///////////       - no integer in columns 0-2 of clastext is a strref
////////////      - nothing in hex notation is a strref
////////////      - all other integers are strrefs
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION apply_to_strrefs_2da
   STR_VAR arguments=""
BEGIN
   SPRINT filename "%SOURCE_RES%"
   TO_LOWER filename
   PATCH_MATCH "%filename%" WITH 
        banttimg clascolr clearair extanim extspeed happy pplane raisdead randcolr repmodst splashs2 splashsc startare startbp startpos strmod strmodex xpbonus xpcap xplevel xplist
   BEGIN
      SET min=0
      SET max=0
      SET col=0
   END
       end15fps endmve1 endmve2 endmve3 intro intro15f melissan xnewarea
   BEGIN
      SET min=10000
      SET max=299999
      SET col=0
   END
      clastext
   BEGIN
      SET min=160
      SET max=299999
      SET col=3
   END
      statdesc
   BEGIN
      SET min=256
      SET max=299999
      SET col=0
   END
   DEFAULT
      SET min=160
      SET max=299999
      SET col=0
   END
   PATCH_IF max>0 BEGIN
    COUNT_2DA_COLS colcount
    COUNT_2DA_ROWS colcount rowcount
    FOR (row=0;row<rowcount;row+=1) BEGIN
     FOR (col=0;col<colcount;col+=1) BEGIN
          READ_2DA_ENTRY row col colcount strref
          PATCH_IF !"%strref%" STRING_MATCHES_REGEXP "[0-9]+$" & STRING_LENGTH "%strref%" <7  BEGIN // we check length here to avoid overflow
            PATCH_IF (min<= strref & strref<= max) BEGIN
             LPF "%arguments%" INT_VAR strref RET strref_new=strref_new  END
             SET_2DA_ENTRY row col colcount "%strref_new%"
            END
          END
    END // end of col FOR
   END // wind of FOR
  END // end_of PATCH_IF
END // end of function


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////  Hook for any of the various editors
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION edit_whatever
    INT_VAR tv=0
            allow_missing=0
    STR_VAR files=""
            file=""
            edits=""
            editstring=""
            location=""
            locbase=""
            locabs=""

BEGIN
   OUTER_SPRINT "files" "%files%%file%"
   ACTION_IF "%files%" STRING_COMPARE "" BEGIN
        LAF return_first_entry STR_VAR list="%files%" RET entry=entry files=list END
        ACTION_MATCH "%entry%" WITH
        ".*\.spl" BEGIN
            OUTER_SPRINT type spell
        END
        ".*\.itm" BEGIN
            OUTER_SPRINT type item
        END
        ".*\.cre" BEGIN
            OUTER_SPRINT type creature
        END
        ".*\.sto" BEGIN
            OUTER_SPRINT type store
        END
        ".*\.are" BEGIN
            OUTER_SPRINT type area
        END
        ".*\.eff" BEGIN
            OUTER_SPRINT type effect
        END
        DEFAULT
           FAIL "File '%entry%' is a type unrecognised by 'edit_whatever'. (Take it up with the advertising standards agency.)"
        END
        OUTER_PATCH_SAVE filename "%entry%" BEGIN
           REPLACE_TEXTUALLY "\..*" ""
        END
        LAF "edit_%type%" INT_VAR tv allow_missing STR_VAR "%type%"="%filename%" edits editstring location locbase locabs END
        LAF edit_whatever INT_VAR tv allow_missing STR_VAR files edits editstring location locbase locabs END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////  Statdesc patcher  - we ignore missing rows
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION add_to_statdesc
    INT_VAR start_row=190
    STR_VAR string= "-1"
            bam = "****"
    RET stat_num
BEGIN
    COPY_EXISTING statdesc.2da override
       COUNT_2DA_ROWS 3 rowcount
       LPF add_to_statdesc_helper INT_VAR start_row rowcount RET stat_num row END
       SET_2DA_ENTRY row 1 3 "%string%"
       SET_2DA_ENTRY row 2 3 "%bam%"
    BUT_ONLY
END

DEFINE_PATCH_FUNCTION add_to_statdesc_helper
      INT_VAR start_row=0
              rowcount=0
      RET stat_num
          row
BEGIN
   PATCH_IF start_row>= rowcount BEGIN
       READ_2DA_ENTRY (rowcount - 1) 0 3 last_entry
       SET stat_num=last_entry + 1
       SET row=rowcount
       INSERT_2DA_ROW rowcount 3 "%stat_num% -1 ****"
   END ELSE BEGIN
     READ_2DA_ENTRY start_row 1 3 entry
     PATCH_IF entry<=0 BEGIN
        READ_2DA_ENTRY start_row 0 3 stat_num
        SET row=start_row
     END ELSE BEGIN
        SET start_row +=1
        LPF add_to_statdesc_helper INT_VAR start_row rowcount RET stat_num row END
     END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////  Find what level a character would be at a given XP level
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION level_at_xp
    INT_VAR xp=0
            num_classes=1
    STR_VAR class=""
    RET level
BEGIN
    // safety check
    ACTION_IF num_classes<1 BEGIN
       OUTER_SET num_classes=1
       LAF warning STR_VAR warning="num_classes variable in the 'level_at_xp' function set to 0 or negative value. Resetting to 1." END
    END
   // adjust the XP for multiclassing
    OUTER_SET xp=xp / num_classes
    // check the table
    COPY_EXISTING xplevel.2da override
         COUNT_2DA_COLS colcount
         LPF get_table_row_coordinate STR_VAR row="%class%" RET rownum END
         PATCH_IF rownum<0 BEGIN
            LPF warning STR_VAR warning="level_at_xp can't determine the level for class %class% as it isn't in xplevel.2da" END
         END ELSE BEGIN
            LPF level_at_xp_core INT_VAR xp rownum colcount RET level END
         END
    BUT_ONLY
END



DEFINE_PATCH_FUNCTION level_at_xp_core
         INT_VAR min_level=1
                 xp=0
                 rownum=0
                 colcount=40
         RET level
BEGIN
      PATCH_IF min_level >= colcount BEGIN
         SET level=min_level
      END ELSE BEGIN
         READ_2DA_ENTRY rownum (min_level+1) colcount xp_here
         PATCH_IF xp_here > xp BEGIN
               SET level=min_level
         END ELSE BEGIN
               SET min_level +=1
               LPF level_at_xp_core INT_VAR min_level xp rownum colcount RET level END
         END
      END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////  Find what level a character would be at the level cap
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION level_at_xp_cap
    STR_VAR class=""
            parent_class=""
    RET level
BEGIN
    ACTION_IF "%parent_class%" STRING_EQUAL "" BEGIN
       OUTER_SPRINT parent_class "%class%"
    END
    // count the number of classes
    OUTER_PATCH_SAVE list "%parent_class%" BEGIN
       REPLACE_TEXTUALLY "_" " "
    END
    LAF length_of_list STR_VAR list RET num_classes=value END
    // get the XP cap
    LAF read_table_entry STR_VAR file=xpcap row="%parent_class%" colnum=1 RET xp=value END
    LAF level_at_xp INT_VAR xp num_classes STR_VAR class RET level END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////  Sort out a SPLPROT entry
/////
/////  through stupid design choices, this uses 'value' both as input and output. Too many uses to change now.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION resolve_splprot_entry 
      INT_VAR stat=0
              value=0
              relation_number=0
      STR_VAR relation=""
      RET value
BEGIN
      OUTER_SET splprot_value=value
      ACTION_MATCH "%relation%" WITH
         equals equal BEGIN 
            OUTER_SET relation_number=1
         END
         greater greater_than BEGIN
            OUTER_SET relation_number=3
         END
         less less_than BEGIN
            OUTER_SET relation_number=2
         END
         greater_equal greater_equals BEGIN
            OUTER_SET relation_number= 4
         END
         less_than_equal less_equal less_than_equals less_than_equals BEGIN
            OUTER_SET relation_number=0
         END
         not_equal BEGIN
            OUTER_SET relation_number=5
         END
         "" BEGIN END
      DEFAULT
         LAF warning STR_VAR warning="unrecognised relation %relation% in resolve_splprot_entry; defaulting to 0" END
         OUTER_SET relation_number=0
      END
      COPY_EXISTING "splprot.2da" override
            READ_2DA_ENTRIES_NOW splprot_array 4
            SET value="-1"
            FOR (i=0;i<splprot_array;i+=1) BEGIN
                   READ_2DA_ENTRY_FORMER splprot_array i 1 this_stat
                   READ_2DA_ENTRY_FORMER splprot_array i 2 this_value
                   READ_2DA_ENTRY_FORMER splprot_array i 3 this_relation
                   PATCH_IF (IS_AN_INT this_stat && IS_AN_INT this_value && IS_AN_INT this_relation) BEGIN
                     PATCH_IF (stat=this_stat && splprot_value=this_value && relation_number=this_relation) BEGIN
                      SET value=i
                      SET i=splprot_array
                     END
                   END
            END
            PATCH_IF value<0 BEGIN
               INSERT_2DA_ROW splprot_array 4 "%splprot_array% %stat% %splprot_value% %relation_number%"
               SET value=splprot_array
            END
      BUT_ONLY
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////  Sort an IDS file into numerical order
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION sort_ids STR_VAR ids="" BEGIN
   ACTION_CLEAR_ARRAY ids_entries
   OUTER_SET max=0
   COPY_EXISTING "%ids%.ids" override
       READ_2DA_ENTRIES_NOW ids_array 2
       // top row is either 'IDS V1.0', or a single row entry, or blank
       PATCH_IF INDEX_BUFFER ("IDS *V1.0")>=0 BEGIN
          SPRINT top_row "IDS V1.0"
       END ELSE BEGIN
          COUNT_2DA_ROWS 1 rowcount_1
          PATCH_IF rowcount_1=ids_array BEGIN
             SPRINT top_row " "
          END ELSE BEGIN
             READ_2DA_ENTRY 0 0 1 top_row
          END
       END
       FOR (i=0;i<ids_array;i+=1) BEGIN
          READ_2DA_ENTRY_FORMER ids_array i 0 num
          PATCH_IF IS_AN_INT num BEGIN
             SET max= num>max ? num : max
             READ_2DA_ENTRY_FORMER ids_array i 1 val
             PATCH_IF "%val%" STRING_COMPARE_CASE DMWW_UNUSED_FOR_DELETION BEGIN
               PATCH_IF VARIABLE_IS_SET $ids_entries("%num%") BEGIN
                SPRINT temp $ids_entries("%num%")
                SPRINT $ids_entries("%num%") "%temp% %val%"
               END ELSE BEGIN
                SPRINT $ids_entries("%num%") "%val%"
               END
             END
          END
       END
   BUT_ONLY
   COPY ".../stratagems-inline/blank" "override/%ids%.ids"
       INSERT_2DA_ROW 0 2 "DW_SORT_IDS_PLACEHOLDER"
       SET rowcount=0
       FOR (num=0;num<=max;num+=1) BEGIN
          PATCH_IF VARIABLE_IS_SET $ids_entries("%num%") BEGIN
             SPRINT list $ids_entries("%num%")
             WHILE "%list%" STRING_COMPARE "" BEGIN
                LPF return_first_entry STR_VAR list RET entry list END
                SPRINT check "%num%--%entry%"
                PATCH_IF !VARIABLE_IS_SET "%check%" BEGIN
                  INSERT_2DA_ROW rowcount 2 "%num% %entry%"
                  SET rowcount+=1
                  SPRINT "%check%" ""
                END
             END
          END
       END
       REPLACE_TEXTUALLY "DW_SORT_IDS_PLACEHOLDER" "%top_row%"
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////  Read a file into an array
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_ACTION_FUNCTION read_file_into_array
   STR_VAR file=""
           location=""
           locbase=""
           locabs=""
           inline="no"
   RET file_length
   RET_ARRAY file_contents
BEGIN
      PRINT "Reading in file %file% to array..."
      ACTION_IF "%inline%" STRING_EQUAL_CASE "yes" BEGIN
        COPY ".../stratagems-inline/%file%" "%workspace%/file_to_read.txt" EVALUATE_BUFFER
      END ELSE BEGIN
        LAF get_directory STR_VAR location locabs locbase RET full_loc=directory END
        ACTION_IF "%full_loc%" STRING_EQUAL_CASE "override" BEGIN
         COPY_EXISTING "%file%" "%workspace%/file_to_read.txt" EVALUATE_BUFFER
        END ELSE BEGIN
         COPY "%full_loc%/%file%" "%workspace%/file_to_read.txt" EVALUATE_BUFFER
        END
      END
      APPEND_OUTER "%workspace%/file_to_read.txt" "" // ensure final line break
      OUTER_SPRINT $file_contents("0") "" // make sure the array exists even if file is empty
      COPY "%workspace%/file_to_read.txt" "%workspace%"
         SET index=0
         REPLACE_EVALUATE "\(.*%WNL%\)"
         BEGIN
            SPRINT $file_contents("%index%") "%MATCH1%"
            index +=1
         END
         ""
      BUT_ONLY
      OUTER_SET file_length=index - 1
      PRINT "...done"
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////  Write an array into a file
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_ACTION_FUNCTION write_array_into_file
   STR_VAR file=""
           file_contents=""
BEGIN  

      PRINT "Outputting array to file %file%..."
      OUTER_SPRINT outputstring ""
      ACTION_PHP_EACH "%file_contents%" AS ind=>line BEGIN
         OUTER_SPRINT outputstring "%outputstring%%line%"
      END
      COPY ".../stratagems-inline/blank" "%file%"
      APPEND_OUTER "%file%" "%outputstring%" KEEP_CRLF
      PRINT "...done"
END

///////////////////////////////////////////////////////////////////////////////
////Add a sectype with no associated string
////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION add_silent_sectype 
   STR_VAR sectype=""
   RET sectype_value
BEGIN
   ADD_SECTYPE "%sectype%" ""
   OUTER_SET sectype_value="%sectype%"
   COPY_EXISTING "msectype.2da" override
       REPLACE_TEXTUALLY "%sectype%\( \|%TAB%\)+[0-9]+\(%WNL%\|%LNL%\|%MNL%\)" "%sectype% -1"
   BUT_ONLY
END
