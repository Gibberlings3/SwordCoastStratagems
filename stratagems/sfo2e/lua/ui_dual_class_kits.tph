/*
describe-library{

Resources used to enable dual-classing into a kit. EE only, requires UI edits.

}
*/

/*
document{dual_class_kits}
{
Do setup work, ready to install specific dual-class kits.

}



*/

DEFINE_ACTION_FUNCTION dual_class_kits 
BEGIN

	// install specific functions and UI edit, if not already there
	
	ACTION_IF !FILE_EXISTS_IN_GAME "m_dw_duf.lua" BEGIN
		COPY ".../stratagems-inline/dual_class_functions.lua" "override/m_dw_duf.lua"
		COPY_EXISTING "ui.menu" override
			REPLACE_TEXTUALLY EXACT_MATCH 
				"characterScreen:OnDualClassButtonClick()" 
				"dwOriginalClass,dwOriginalKit=dwFindClassKit(2);characterScreen:OnDualClassButtonClick()"
		BUT_ONLY
	END

	// collect all the information about kits, if not collected already
	
	ACTION_IF !FILE_EXISTS_IN_GAME "m_dw_vce.lua" BEGIN
		LAF collect_dual_class_kit_data END
	END ELSE BEGIN
		LAF check_label STR_VAR label=dw#multiclass_specialists_permitted RET value END
		ACTION_IF value BEGIN
			LAF ui_dualclass_specialist_bonus_spells END
			COPY_EXISTING "m_dw_vce.lua" override
				REPLACE_TEXTUALLY "2999999" "2"
		END
	END
	
	
END


DEFINE_ACTION_FUNCTION collect_dual_class_kit_data//internal 
BEGIN

	LAF check_label STR_VAR label=dw#multiclass_specialists_permitted RET dualclass_specialist=value END

	// set up dedicated lua for the autogenerated override_chargen_kit entries
	
	COPY ".../stratagems-inline/blank" "override/m_dw_vce.lua"

	// hardcoded manual check for barbarian virtual class
	
	OUTER_SET barbarian_vc=RESOURCE_CONTAINS "m_dw_vcd.lua" "class_barbarian"

	//get baseclass names
	
	ACTION_IF is_iwd BEGIN
		ACTION_GET_STRREF 814 fighter_string
		ACTION_GET_STRREF 817 mage_string	
	END ELSE BEGIN
		ACTION_GET_STRREF 10174 fighter_string
		ACTION_GET_STRREF 3139 mage_string
	END 
	ACTION_GET_STRREF 1079 cleric_string
	ACTION_GET_STRREF 1080 druid_string
	ACTION_GET_STRREF 1077 ranger_string
	ACTION_GET_STRREF 1082 thief_string


	ACTION_IF !VARIABLE_IS_SET $ui_clastext_data(FIGHTER CLASSID) BEGIN
		LAF 2da_read STR_VAR file=clastext.2da RET_ARRAY ui_clastext_rows=rows ui_clastext_data=array END
	END
	OUTER_PATCH "" BEGIN
		PHP_EACH ui_clastext_rows AS kit=>discard BEGIN
			PATCH_MATCH "%kit%" WITH
			FIGHTER MAGE CLERIC DRUID THIEF RANGER BEGIN
				class=$ui_clastext_data("%kit%" CLASSID)
				SET $kitID("%kit%")=0
				SET $name("%kit%")=$ui_clastext_data("%kit%" MIXED)
				SET $desc("%kit%")=$ui_clastext_data("%kit%" DESCSTR)
				SPRINT $allow("%kit%") "{[1]={newclass=%class%, oldkit=0}}"
				SET $parent("%kit%")=IDS_OF_SYMBOL (class "%kit%")
			END
			DEFAULT
			END
		END
	END
	
	ACTION_IF !VARIABLE_IS_SET $ui_kitlist_data(RESERVE ROWNUMBER) BEGIN
		LAF 2da_read STR_VAR file=kitlist.2da rowname_column=ROWNAME RET_ARRAY ui_kitlist_rows=rows ui_kitlist_data=array END
	END
	
	OUTER_PATCH "" BEGIN
		PHP_EACH ui_kitlist_rows AS kit=>discard BEGIN
			PATCH_IF IS_AN_INT $ui_kitlist_data("%kit%" MIXED) BEGIN
				kitID=$ui_kitlist_data("%kit%" ROWNUMBER)
				name=$ui_kitlist_data("%kit%" MIXED)
				desc=$ui_kitlist_data("%kit%" HELP)
				parent=$ui_kitlist_data("%kit%" CLASS)
				TO_UPPER kit
				PATCH_IF IS_AN_INT name BEGIN
					PATCH_MATCH "%parent%" WITH 1 2 3 4 11 12 7 8 9 10 13 14 15 16 17 18 BEGIN // classes that can be part of a multiclass combo
					  SET $kitID("%kit%")=kitID
					  SET $name("%kit%")=name
					  SET $desc("%kit%")=desc
					  SET $parent("%kit%")=parent
					  SPRINT $allow("%kit%") "{[1]={oldkit=%kitID%}}"
					  PATCH_IF dualclass_specialist BEGIN
						classvar=2
					  END ELSE BEGIN
						classvar=2999999
					  END
					PATCH_MATCH "%kit%" WITH
					abjurer conjurer transmuter invoker diviner enchanter illusionist necromancer wildmage BEGIN
						SPRINT $allow("%kit%") "{[1]={oldkit=%kitID%},[%classvar%]={oldkit=0, newclass=1}}"
					END
					DEFAULT
					END
					END
					DEFAULT
					END
					// do name overrides
					INNER_ACTION BEGIN
						ACTION_GET_STRREF name name_string
						//mage/X
						ACTION_MATCH "%parent%" WITH
						2 3 BEGIN
							OUTER_SET override=RESOLVE_STR_REF ("%name_string%/%mage_string%")
							LAF override_chargen_kit_name INT_VAR override use_tra=0 STR_VAR lua=m_dw_vce kit class=MAGE END		
						END
						4 BEGIN
							OUTER_SET override=RESOLVE_STR_REF ("%mage_string%/%name_string%")
							LAF override_chargen_kit_name INT_VAR override use_tra=0 STR_VAR lua=m_dw_vce kit class=MAGE END					
						END
						DEFAULT
						END		
						// fighter/X
						ACTION_MATCH "%parent%" WITH
						1 3 4 11 BEGIN // 
							OUTER_SET override=RESOLVE_STR_REF ("%fighter_string%/%name_string%")
							LAF override_chargen_kit_name INT_VAR override use_tra=0 STR_VAR lua=m_dw_vce kit class=FIGHTER END
						END
						DEFAULT
						END
						// cleric/X
						ACTION_MATCH "%parent%" WITH
						2 BEGIN
							OUTER_SET override=RESOLVE_STR_REF ("%name_string%/%cleric_string%")
							LAF override_chargen_kit_name INT_VAR override use_tra=0 STR_VAR lua=m_dw_vce kit class=CLERIC END
						END
						1 4 12 BEGIN
							OUTER_SET override=RESOLVE_STR_REF ("%cleric_string%/%name_string%")
							LAF override_chargen_kit_name INT_VAR override use_tra=0 STR_VAR lua=m_dw_vce kit class=CLERIC END
					
						END
						DEFAULT
						END
						//thief/X
						ACTION_MATCH "%parent%" WITH
						1 2 3 BEGIN
							OUTER_SET override=RESOLVE_STR_REF ("%name_string%/%thief_string%")
							LAF override_chargen_kit_name INT_VAR override use_tra=0 STR_VAR lua=m_dw_vce kit class=THIEF END			
						END
						DEFAULT
						END
						//X/druid
						ACTION_MATCH "%parent%" WITH
						2 BEGIN
							OUTER_SET override=RESOLVE_STR_REF ("%name_string%/%druid_string%")
							LAF override_chargen_kit_name INT_VAR override use_tra=0 STR_VAR lua=m_dw_vce kit class=DRUID END

						END
						DEFAULT
						END
						// X/ranger
						ACTION_MATCH "%parent%" WITH
						3 BEGIN
							OUTER_SET override=RESOLVE_STR_REF ("%name_string%/%ranger_string%")
							LAF override_chargen_kit_name INT_VAR override use_tra=0 STR_VAR lua=m_dw_vce kit class=RANGER END

						END
						DEFAULT
						END
					END // end of INNER_ACTION
				END
			END
		END
	END
	
	COPY_EXISTING "alignmnt.2da" override
		COUNT_2DA_COLS colcount
		FOR (col=1;col<colcount;++col) BEGIN
			READ_2DA_ENTRY 0 (col - 1) (colcount - 1) col_header
			SPRINT $header("%col%") "%col_header%"
		END
		READ_2DA_ENTRIES_NOW alignmnt_data colcount
		FOR (row=0;row<alignmnt_data;++row) BEGIN
			READ_2DA_ENTRY_FORMER alignmnt_data row 0 kit
			TO_UPPER kit
			PATCH_IF VARIABLE_IS_SET $kitID("%kit%") BEGIN
				SPRINT align_data ""
				FOR (col=1;col<=9;++col) BEGIN
					READ_2DA_ENTRY_FORMER alignmnt_data row col val
					PATCH_IF val=0 BEGIN
						SPRINT align $header("%col%")
						SPRINT align_data "%align_data%%align%=true, "
					END
				END
				SPRINT $align_data("%kit%") "%align_data%"
			END
		
		END
	BUT_ONLY
	
	COPY_EXISTING "clsrcreq.2da" override
		COUNT_2DA_COLS colcount
		FOR (col=1;col<colcount;++col) BEGIN
			READ_2DA_ENTRY 0 (col - 1) (colcount - 1) col_header
			SET $header("%col%") =IDS_OF_SYMBOL (race "%col_header%")
		END
		READ_2DA_ENTRIES_NOW clsrcreq_data colcount
		FOR (row=0;row<clsrcreq_data;++row) BEGIN
			READ_2DA_ENTRY_FORMER clsrcreq_data row 0 kit
			TO_UPPER kit
			PATCH_IF VARIABLE_IS_SET $kitID("%kit%") BEGIN
				SPRINT race_data ""
				FOR (col=1;col<colcount;++col) BEGIN
					READ_2DA_ENTRY_FORMER clsrcreq_data row col val
					PATCH_IF val=0 BEGIN
						SPRINT race $header("%col%")
						SPRINT race_data "%race_data%[%race%]=true, "
					END
				END
				SPRINT $race_data("%kit%") "%race_data%"
			END
		
		END
	BUT_ONLY
	
	COPY_EXISTING "abclasrq.2da" override
		COUNT_2DA_COLS colcount
		READ_2DA_ENTRIES_NOW abil_data colcount
		FOR (row=0;row<abil_data;++row) BEGIN
			READ_2DA_ENTRY_FORMER abil_data row 0 kit
			TO_UPPER kit
			PATCH_IF VARIABLE_IS_SET $kitID("%kit%") BEGIN
				READ_2DA_ENTRY_FORMER abil_data row 1 str
				READ_2DA_ENTRY_FORMER abil_data row 2 dex
				READ_2DA_ENTRY_FORMER abil_data row 3 con
				READ_2DA_ENTRY_FORMER abil_data row 4 int
				READ_2DA_ENTRY_FORMER abil_data row 5 wis
				READ_2DA_ENTRY_FORMER abil_data row 6 cha
			END
			SPRINT data_here ""
			PATCH_FOR_EACH abil IN str dex con int wis cha BEGIN
				val=EVAL "%%abil%%"
				PATCH_IF val>0 BEGIN
					SPRINT data_here "%data_here%%abil%=%val%, "
				END
			END
			SPRINT $abil_data("%kit%") "%data_here%"
		END
	BUT_ONLY
	
	
	<<<<<<<< .../stratagems-inline/m_dw_dud.lua
	dwKitData={}
	>>>>>>>>
	
	COPY ".../stratagems-inline/m_dw_dud.lua" override
	
	OUTER_SPRINT data ""
	ACTION_PHP_EACH kitID AS kit=>id BEGIN
		OUTER_SET proceed=1
		ACTION_IF barbarian_vc && "%kit%" STR_EQ "barbarian" BEGIN
			OUTER_SET proceed=0
		END
		ACTION_IF proceed BEGIN
			OUTER_SPRINT data_here "dwKitData['%kit%']={ id=%id%, "
			ACTION_FOR_EACH entry IN name desc allow parent BEGIN
				OUTER_SPRINT val $"%entry%"("%kit%")
				OUTER_SPRINT data_here "%data_here% %entry%=%val%, "
			END
			OUTER_SPRINT align_data $align_data("%kit%")
			OUTER_SPRINT data_here "%data_here% forbid_alignment={%align_data%}, "
			OUTER_SPRINT race_data $race_data("%kit%")
			OUTER_SPRINT data_here "%data_here% forbid_race={%race_data%}, "
			OUTER_SPRINT abil_data $abil_data("%kit%")
			OUTER_SPRINT data_here "%data_here% ability_min={%abil_data%}, "
			OUTER_SPRINT data_here "%data_here%}"
			OUTER_SPRINT data "%data%%data_here%%WNL%"
		END
	END
	APPEND "m_dw_dud.lua" "%data%" KEEP_CRLF
	


END

/*
document{add_dual_class_kit_option}
{
Enable dual-classing from kit 'oldkit' of old class 'oldclass', into kit 'kit' of class 'newclass'. Class entries should be IDS entries like 'FIGHTER'. Kit entries should 
be kitlist.2da rownames.
}


*/

DEFINE_ACTION_FUNCTION add_dual_class_kit_option
	STR_VAR kit="" 
			oldclass="" 
			oldkit="" 
			newclass=""
BEGIN
	ACTION_TO_UPPER kit
	// remove ' from entries
	ACTION_FOR_EACH variable IN kit oldkit oldclass newclass BEGIN
		OUTER_SPRINT old EVAL "%%variable%%"
		OUTER_PATCH_SAVE new "%old%" BEGIN
			REPLACE_TEXTUALLY "'.*" ""
		END
		OUTER_SPRINT "%variable%" "%new%"
	END
	// sanity check
	
	ACTION_IF !RESOURCE_CONTAINS "kitlist.2da" "%kit%" BEGIN
		LAF warning STR_VAR warning="Tried to enable dual-class option for kit %kit% but it doesn't exist" END
	END ELSE BEGIN
	// setup
	ACTION_IF !FILE_EXISTS_IN_GAME "m_dw_due.lua" BEGIN
		COPY ".../stratagems-inline/blank" "override/m_dw_due.lua"
	END
	OUTER_SPRINT data ""
	// get relevant parameters
	// old class
	ACTION_IF "%oldclass%" STRING_COMPARE "" BEGIN
		OUTER_SET number = IDS_OF_SYMBOL (class "%oldclass%")
		ACTION_IF number>=0 BEGIN
			OUTER_SPRINT data "%data%oldclass=%number%, "
		END
	END
	ACTION_IF "%newclass%" STRING_COMPARE "" BEGIN
		OUTER_SET number = IDS_OF_SYMBOL (class "%newclass%")
		ACTION_IF number>=0 BEGIN
			OUTER_SPRINT data "%data%newclass=%number%, "
		END ELSE BEGIN // this applies when it's virtual
			OUTER_SPRINT data "%data%newclass='%newclass%', "
		END
	END
	ACTION_IF "%oldkit%" STRING_COMPARE "" BEGIN
		OUTER_SET number="-1"
		ACTION_MATCH "%oldkit%" WITH
		trueclass fighter mage cleric thief ranger druid 
		BEGIN
			OUTER_SET number=0
		END 
		DEFAULT
		  COPY_EXISTING "kitlist.2da" "%workspace%"
			COUNT_2DA_COLS colcount
			READ_2DA_ENTRIES_NOW kitlist_data colcount
			FOR (row=0;row<kitlist_data;++row) BEGIN
				READ_2DA_ENTRY_FORMER kitlist_data row 1 kit_here
				PATCH_IF "%kit_here%" STRING_EQUAL_CASE "%oldkit%" BEGIN
					READ_2DA_ENTRY_FORMER kitlist_data row 0 number
				END
			END
		  BUT_ONLY
		END
		ACTION_IF number>=0 BEGIN
			OUTER_SPRINT data "%data%oldkit=%number%, "
		END ELSE BEGIN
			LAF warning STR_VAR warning="Dual-class option for kit %kit% references non-existent kit %oldkit%" END
		END
	END
	// write data
	ACTION_IF "%data%" STRING_COMPARE_CASE "" BEGIN
		APPEND "m_dw_due.lua" "table.insert(dwKitData['%kit%'].allow,{%data%})%WNL%"
	END
	END



END

DEFINE_ACTION_FUNCTION ui_dualclass_specialist_bonus_spells BEGIN

	// build resources to give dual-classed specialists their bonus spells (the engine won't grant them) and add to CLAB
	
	ACTION_IF !FILE_EXISTS_IN_GAME "dwdcmb.spl" BEGIN
	
		LAF kit_label_original_classes END
	
		CREATE spl dwdcmb
			LPF add_basic_spell_ability END
			LPF ADD_SPELL_EFFECT INT_VAR opcode=326 timing=9 target=2 parameter1=IDS_OF_SYMBOL(splstate ORIGINAL_CLASS_FIGHTER) parameter2=110 STR_VAR resource=dwdcmbp END
			LPF ADD_SPELL_EFFECT INT_VAR opcode=326 timing=9 target=2 parameter1=IDS_OF_SYMBOL(splstate ORIGINAL_CLASS_CLERIC) parameter2=110 STR_VAR resource=dwdcmbp END
			LPF ADD_SPELL_EFFECT INT_VAR opcode=326 timing=9 target=2 parameter1=IDS_OF_SYMBOL(splstate ORIGINAL_CLASS_THIEF) parameter2=110 STR_VAR resource=dwdcmbp END

		CREATE spl dwdcmbp
			LPF add_basic_spell_ability END
			LPF ADD_SPELL_EFFECT INT_VAR opcode=321 target=2 timing=9 STR_VAR resource=dwdcmbp END // probably not needed, but let's be safe
			LPF ADD_SPELL_EFFECT INT_VAR opcode=42 target=2 timing=9 parameter1=1 parameter2=0b111111111 END	
		
		
		LAF kit_edit_all INT_VAR skip_trueclass=1 STR_VAR parent_class="MAGE" edits="sfo_internal_struct.kit_apply_powers{dwdcmb 1}" struct=sfo_internal_struct END
		
	END
END

<<<<<<<< .../stratagems-inline/dual_class_functions.lua


function dwDualClassKitList()

	kitList={}
	for _,v in pairs (dwKitData) do
		if dwDualClassKitAllowed(v) then
				table.insert(kitList,v)
		end	
	end
	
	return kitList

end
function dwDualClassToVirtualClassAllowed(vc)

	if dwOriginalClass==vc.id then
		return false
	end
	empty=true
	for _,kit in pairs (dwKitData) do
		if empty and dwDualClassKitAllowed(kit,vc.ident) then
			empty=false
		end
	end
	return not empty




end

function dwDualClassKitAllowed(kit,newclass)
	
	-- inherit dwOriginalClass, dwOriginalKit, dwChargenClassId from environment

	if not newclass then
		if dwCurrentVirtualClass then
			newclass=dwCurrentVirtualClass.ident
		else
			newclass=dwChargenClassId
		end
	end

	allowed=nil
	
	for _,v in pairs (kit.allow) do
		allowed_here=true
		if (v.oldkit) then
			if v.oldkit ~= dwOriginalKit then
				allowed_here=nil
			end
		end
		if (v.oldclass) then
			if v.oldclass ~= dwOriginalClass then
				allowed_here=nil
			end
		end
		if (v.newclass) then
			if v.newclass ~= newclass then
				allowed_here=nil
			end
		elseif type(newclass)=='string' then -- virtual classes must be explicitly permitted
			allowed_here=nil
		end
		if allowed_here then 
			allowed=true
		end
	end
	
	-- now check alignment, stats, race
	
	if allowed then
		if kit.forbid_alignment[dwFindAlignment(2)] then
			allowed=nil
		end
		if kit.forbid_race[dwFindRace(2)] then
			allowed=nil
		end
		abil_list={[1]='str',[2]='dex'}
		for _,v in pairs (abil_list) do
			val=string.gsub(characters[currentID].attr[v].base, '/[0-9]+', '')
			abil=tonumber (val)
			if kit.ability_min[v] then
				if kit.ability_min[v]>abil then
					allowed=nil
				end
			end
		end
		
	end
	
	return allowed

end



>>>>>>>>