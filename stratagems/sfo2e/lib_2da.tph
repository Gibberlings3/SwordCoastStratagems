//////////////////////////////////////////////////////////////////////////////////////
/*
describe-library
{
Functions for manipulating 2d arrays via their (assumed uppercase) rows and columns. The
main use case is reading these 2d arrays out of .2da game files and extracting data from
them, and/or manipulating them and writing them back in. This is (hopefully) a much simpler
and more transparent way to manipulate 2das than by READ_2DA_ENTRY and friends.</p>

<p>Functions here should engage with the general 2da format and shouldn't refer to specific
features of particular game's 2das. They should start with "2da_".</p>

<p>This library can handle these file formats:
<ol>
<li>Standard, legally-formatted 2da files.</li>
<li>IDS files, which are read in with an added set of row headers which are integers labelled
from 0, and with columns 'int' and 'symbol'.</li>
<li>Tables with column headers, which are read in with an added set of row headers as for IDS files.</li>
</ol>
}
*/
//////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_read}
{
Read a 2da file (or, in patch context, the current 2da file) into a 2d array. Also return an array of uppercased row headers and
column headers, in the format row_label=>row_number. ('case' controls the case of the
row and column headers; it's uppercase by default on genuine 2das, mixed by default otherwise).
The default value is also returned, as 'default'. (On non-2da files, * is returned)

If you don't specify a path for the 2da file, it's assumed to be a game file.

In action context, if the file doesn't exist return 0; otherwise, return 1. Also
whine if it doesn't exist, unless silent=1.

If the file is a 2da, and 'reflect' is set, reverse rows and columns.  If it's a 2da, and "rowname_column" is set, use that column
(if it's present) for the row names instead of the usual entries. In the latter case, we add a new 'ROWNUMBER' column
containing column zero. (This is not compatible with 'reflect'.)s

If 'rowmap' and/or 'colmap' are set, they get applied to the row and column entries before the array is constructed.

If the file contains WEIDU-style // comments, they are removed. (You can override this by setting remove_comments to 0.)
}
*/
//////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION "2da_read"
	INT_VAR silent=0//boolean
			reflect=0//boolean
			allow_incomplete_lines=0//obsolete
			remove_comments=1//boolean
	STR_VAR type=""//[2da|ids|table_header|table_no_header]
			rowmap=""//function
			colmap=""//function
			rowname_column=""
			case=""//[upper|lower|mixed]
	RET default
	RET_ARRAY columns rows array
BEGIN
	SPRINT default "*"
	PATCH_IF "%rowname_column%" STR_CMP "" && reflect BEGIN
		PATCH_WARN "You are calling 2da_read with both reflect=1 and a nonempty rowname_column, which is not reliably supported"
	END
	LPF anon_check INT_VAR has_output=1 STR_VAR function="%rowmap%" RET rowmap=function END
	LPF anon_check INT_VAR has_output=1 STR_VAR function="%colmap%" RET colmap=function END
	// initialize
	CLEAR_ARRAY columns
	CLEAR_ARRAY rows
	CLEAR_ARRAY array
	// remove comments
	PATCH_IF remove_comments BEGIN
		REPLACE_TEXTUALLY "//.*" ""
	END
	// try to infer type
	PATCH_IF "%type%" STR_EQ "" BEGIN
		PATCH_IF "%rowmap%" STR_CMP "" || "%colmap%" STR_CMP "" BEGIN
			SPRINT type "2da"
		END ELSE BEGIN
			READ_ASCII 0x0 sig (3)
			PATCH_MATCH "%sig%" WITH 
			"2da" "ids" BEGIN
				SPRINT type "%sig%"
			END
			DEFAULT
				PATCH_MATCH "%SOURCE_EXT%" WITH 
				"2da" "ids" BEGIN
					SPRINT type "%SOURCE_EXT%"
				END
				DEFAULT
					SPRINT type "table_header"
				END
			END
		END
	END
	// get column width & length
	COUNT_2DA_COLS colcount
	COUNT_2DA_ROWS colcount rowcount
	PATCH_MATCH "%type%" WITH
	"2da" BEGIN
		LPF 2da_fix INT_VAR apply_to_file=0 RET fixed_file END
		INNER_PATCH "%fixed_file%" BEGIN
			// get the default
			READ_2DA_ENTRY 1 0 1 default
			SPRINT default "%default%"
			// check if it's empty
			COUNT_2DA_ROWS 1 empty_check
			is_empty=(empty_check=3)
			is_blank=(empty_check=2)
			// get the col headers (& also the lookup column if appropriate)
			PATCH_IF !is_blank BEGIN
				lookup_col_num=0
				COUNT_2DA_COLS colcount
				COUNT_2DA_ROWS colcount rowcount
				PATCH_MATCH "%colcount%" WITH
				2 BEGIN
					col_row=2
					main_row=1
				END
				3 BEGIN
					col_row=1
					main_row=0
				END
				DEFAULT
					col_row=0
					main_row=0
				END
				READ_2DA_ENTRIES_NOW 2da_coldata (colcount - 1)
				FOR (col=1;col<colcount;++col) BEGIN
					READ_2DA_ENTRY_FORMER 2da_coldata col_row (col - 1) value
					PATCH_MATCH "%value%" WITH 
					"%rowname_column%" BEGIN
						lookup_col_num=col
					END
					DEFAULT
					END
					PATCH_MATCH "%case%" WITH
					lower BEGIN
						TO_LOWER value 
					END
					upper BEGIN
						TO_UPPER value
					END	
					mixed BEGIN
					END
					DEFAULT
						TO_UPPER value
					END
					PATCH_IF !reflect BEGIN
						SET $columns("%value%")=col
					END ELSE BEGIN
						SET $rows("%value%")=col			
					END
				END
				PATCH_IF is_empty BEGIN
					LPF array_map STR_VAR array=columns keymap="%colmap%" RET_ARRAY columns=array END
				END ELSE BEGIN
					// get the rows
					READ_2DA_ENTRIES_NOW 2da_data colcount
					FOR (rownum=main_row;rownum<2da_data;++rownum) BEGIN
						READ_2DA_ENTRY_FORMER 2da_data rownum lookup_col_num value
						PATCH_MATCH "%case%" WITH
						lower BEGIN
							TO_LOWER value 
						END
						upper BEGIN
							TO_UPPER value
						END	
						mixed BEGIN
						END
						DEFAULT
							TO_UPPER value
						END		
						PATCH_IF !reflect BEGIN	
							SET $rows("%value%")=rownum
						END ELSE BEGIN
							SET $columns("%value%")=rownum
						END
					END
					// if we're using rowname_column, store the actual row labels
					// map rows and columns if needed
					LPF array_map STR_VAR array=columns keymap="%colmap%" RET_ARRAY columns=array END
					LPF array_map STR_VAR array=rows keymap="%rowmap%" RET_ARRAY rows=array END
					

					PHP_EACH rows AS row=>row_int BEGIN
						// get rownumbers if we're using rowname_column
						PATCH_IF lookup_col_num>0 BEGIN
							READ_2DA_ENTRY_FORMER 2da_data row_int 0 rownumber
							PATCH_IF !reflect BEGIN
								SPRINT $array("%row%" "ROWNUMBER") "%rownumber%"
							END ELSE BEGIN
								SPRINT $array("ROWNUMBER" "%row%") "%rownumber%"				
							END
						END	
						// main data					
						PHP_EACH columns AS col=>col_int BEGIN		
							PATCH_IF !reflect BEGIN
								READ_2DA_ENTRY_FORMER 2da_data row_int col_int entry
							END ELSE BEGIN
								READ_2DA_ENTRY_FORMER 2da_data col_int row_int entry
							END
							SPRINT $array("%row%" "%col%") "%entry%"
						END
					END	
				END
			END
		END
	END
	"ids" BEGIN
		READ_2DA_ENTRIES_NOW 2da_data 2
		// set cols
			SET $columns("int")=0
			SET $columns("sym")=1
		// get main data
		count=0
		FOR (row=0;row<2da_data;++row) BEGIN
			READ_2DA_ENTRY_FORMER 2da_data row 0 int
			READ_2DA_ENTRY_FORMER 2da_data row 1 sym
			PATCH_IF IS_AN_INT int BEGIN
				SET $array("%count%" "int")=int
				SPRINT $array("%count%" "sym") "%sym%"
				++count
			END
		END
		// set rows
		FOR (row=0;row<count;++row) BEGIN
			SET $rows("%row%")=row
		END

	END	
	"table_header" BEGIN
		COUNT_2DA_COLS colcount
		READ_2DA_ENTRIES_NOW 2da_data colcount
		// get columns
		FOR (col=0;col<colcount;++col) BEGIN
			READ_2DA_ENTRY_FORMER 2da_data 0 col value
			PATCH_MATCH "%case%" WITH
			lower BEGIN
				TO_LOWER value 
			END
			upper BEGIN
				TO_UPPER value
			END	
			DEFAULT
			END
			SET $columns("%value%")=col
		END
		// get data; set rows
		FOR (ind=1;ind<2da_data;++ind) BEGIN
			row=ind - 1
			SET $rows("%row%")=row
			PHP_EACH columns AS col=>colnum BEGIN
				READ_2DA_ENTRY_FORMER 2da_data ind colnum value
				SPRINT $array("%row%" "%col%") "%value%"
			END
		END
	END
	"table_noheader" BEGIN
		COUNT_2DA_COLS colcount
		READ_2DA_ENTRIES_NOW 2da_data colcount
		// set columns
		FOR (col=0;col<colcount;++col) BEGIN
			SET $columns("%col%")=col
		END
		// get data; set rows
		FOR (ind=1;ind<2da_data;++ind) BEGIN
			row=ind - 1
			SET $rows("%row%")=row
			PHP_EACH columns AS col=>colnum BEGIN
				READ_2DA_ENTRY_FORMER 2da_data ind colnum value
				SPRINT $array("%row%" "%col%") "%value%"
			END
		END
	
	END
	DEFAULT
		PATCH_FAIL "2da_read: unidentified read type %type%"
	END

END

DEFINE_ACTION_FUNCTION "2da_read"
	INT_VAR silent=0//boolean
			inline=0//boolean
			reflect=0//boolean
			allow_incomplete_lines=0//obsolete
	STR_VAR file="" 
			case=""//[upper|lower|mixed]
			path=""
			type=""
			location=""
			locbase=""
			rowmap=""//function
			colmap=""//function
			rowname_column=""
	RET value
	RET_ARRAY columns rows array
BEGIN
	ACTION_IF FILE STR_EQ "" BEGIN
		FAIL "2da_read called with empty value of 'file'"
	END
	ACTION_CLEAR_ARRAY columns
	ACTION_CLEAR_ARRAY rows
	ACTION_CLEAR_ARRAY array
	ACTION_IF inline && INDEX ("[/\]" "%file%")<0 BEGIN
		OUTER_SPRINT file ".../stratagems-inline/%file%" 
	END
	LAF sfo_path STR_VAR file path location locbase RET file_path path END
	ACTION_IF "%path%" STR_EQ "" &&!inline BEGIN
		ACTION_IF FILE_EXISTS_IN_GAME "%file%" BEGIN
			COPY_EXISTING - "%file%" nowhere
				LPF 2da_read INT_VAR silent reflect allow_incomplete_lines STR_VAR rowname_column case rowmap colmap type RET_ARRAY columns rows array END
			BUT_ONLY
			OUTER_SET value=1
		END ELSE BEGIN
			OUTER_SET value=0
			ACTION_IF !silent BEGIN
				WARN "2da_read: supposed game file %file% does not exist"
			END
		END
	END ELSE BEGIN
		ACTION_IF FILE_EXISTS "%file_path%" || inline BEGIN
			COPY - "%file_path%" nowhere
				LPF 2da_read INT_VAR silent reflect allow_incomplete_lines STR_VAR rowname_column case rowmap colmap type RET_ARRAY columns rows array END
			BUT_ONLY
			OUTER_SET value=1
		END ELSE BEGIN
			OUTER_SET value=0
			ACTION_IF !silent BEGIN
				WARN "2da_read: supposed file %file_path% does not exist"
			END		
		END
	END
END

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_write}
{
Write a 2d array into a 2da file (or, in patch context, the current 2da file). 

If you don't specify a path for the 2da file, it's assumed to be a game file.

If 'number_rows' is set to 1, the row names are replaced by integers, counting upwards from 0.
If 'reflect' is set to 1, rows and columns are swapped.

If you don't specify the default element, we try to read it from the current file
}
*/
//////////////////////////////////////////////////////////////////////////////////////
DEFINE_PATCH_FUNCTION 2da_write
	INT_VAR reflect=0//boolean
			number_rows=0//boolean
	STR_VAR array=""//array
			type=""//[2da|ids|table_header|table_noheader]
			default=""
			case="mixed"//[mixed|upper|lower]
BEGIN
	// get cols, rows
	LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
	// try to infer type
	PATCH_IF "%type%" STR_EQ "" BEGIN
		PATCH_IF "%default%" STR_CMP "*" BEGIN
			SPRINT type "2da"
		END ELSE BEGIN
			PATCH_IF BUFFER_LENGTH>=3 BEGIN
				READ_ASCII 0x0 sig
				PATCH_MATCH "%sig%" WITH
				"2da" "ids" BEGIN
					SPRINT type "%sig%"
				END	
				DEFAULT
				END
			END
		END
	END
	PATCH_IF "%type%" STR_EQ "" BEGIN
		PATCH_MATCH "%DEST_EXT%" WITH
		"2da" "ids" BEGIN
			SPRINT type "%DEST_EXT%"
		END 
		DEFAULT
		END
	END
	PATCH_IF "%type%" STR_EQ "" BEGIN
		found_first_col=0
		found_first_row=0
		found_second_col=0
		PHP_EACH rows AS row=>discard BEGIN
			PATCH_IF !found_first_row BEGIN
				SPRINT first_row "%row%"
				found_first_row=1
			END
		END
		PHP_EACH columns AS col=>discard BEGIN
			PATCH_IF !found_first_col BEGIN
				SPRINT first_col "%col%"
				found_first_col=1
			END ELSE
			PATCH_IF !found_second_col BEGIN
				SPRINT second_col "%col%"
				found_second_col=1
			END	
		END	
		PATCH_IF "%first_col%" STR_EQ int && "%second_col%" STR_EQ "sym" BEGIN
			SPRINT type ids
		END ELSE
		PATCH_IF IS_AN_INT "%first_col%" BEGIN
			SPRINT type table_noheader
		END ELSE
		PATCH_IF IS_AN_INT "%first_row%" BEGIN
			SPRINT type table_header
		END ELSE BEGIN
			SPRINT type 2da
		END
	END

	PATCH_MATCH "%type%" WITH
	"2da" BEGIN
		// try to find default, if not set already
		PATCH_IF "%default%" STR_EQ "" BEGIN
			LPF 2da_find_default RET default=value END
			PATCH_IF "%default%" STR_EQ "NOT_2DA" BEGIN
				SPRINT default "*"
			END
		END
		// initialise
		SPRINT data "2DA V1.0%WNL%%default%%WNL%"
		// extract col data
		PATCH_IF !reflect BEGIN
			LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
		END ELSE BEGIN
			LPF array_keys STR_VAR array RET_ARRAY rows=keys2 columns=keys1 END		
		END
		// write column headers
		PHP_EACH columns AS col=>discard BEGIN
			SPRINT data "%data%%col%%TAB%"
		END
		SPRINT data "%data%"
		// write rows
		rowcount=0
		PHP_EACH rows AS row=>discard BEGIN
			PATCH_IF !number_rows BEGIN
				SPRINT rowname "%row%"
			END ELSE BEGIN
				SPRINT rowname "%rowcount%"
			END
			SPRINT data "%data%%WNL%%rowname%%TAB%"
			++rowcount
			PHP_EACH columns AS col=>discard2 BEGIN
				PATCH_IF !reflect BEGIN
					SPRINT k1 "%row%"
					SPRINT k2 "%col%"
				END ELSE BEGIN
					SPRINT k1 "%col%"
					SPRINT k2 "%row%"
				END
				PATCH_IF VARIABLE_IS_SET $"%array%"("%k1%" "%k2%") BEGIN
					SPRINT val $"%array%"("%k1%" "%k2%")
				END ELSE BEGIN
					SPRINT val "%default%"
				END
				SPRINT data "%data%%val%%TAB%"
			END
		END
		// impose case
		PATCH_MATCH "%case%" WITH
		upper BEGIN
			TO_UPPER data
		END
		lower BEGIN
			TO_LOWER data
			INNER_PATCH_SAVE data "%data%" BEGIN
				WRITE_ASCII 0x0 "2DA V1.0"
			END
		END
		DEFAULT
		END
		// write to file and justify
		DELETE_BYTES 0x0 BUFFER_LENGTH
		INSERT_BYTES 0x0 STRING_LENGTH "%data%"
		WRITE_ASCII 0x0 "%data%"
		COUNT_2DA_ROWS 0 rowcount
		PATCH_IF rowcount>2 BEGIN
			PRETTY_PRINT_2DA
			REPLACE_TEXTUALLY "^2DA[ %TAB%]+V1.0" "2DA V1.0"
		END
	END
	"ids" BEGIN
		SPRINT data "IDS V1.0%WNL%"// extract col data
		PHP_EACH "%array%" AS k=>v BEGIN
			PATCH_IF "%k_1%" STR_EQ "sym" BEGIN
				SPRINT data "%data%%TAB%%v%%WNL%"
			END ELSE BEGIN
				SPRINT data "%data%%v%"
			END
		END
		// write to file
		DELETE_BYTES 0x0 BUFFER_LENGTH
		INSERT_BYTES 0x0 STRING_LENGTH "%data%"
		WRITE_ASCII 0x0 "%data%"
	END
	"table_header" "table_noheader" BEGIN
		SPRINT data ""
		LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
		PATCH_IF "%type%" STR_EQ "table_header" BEGIN
			PHP_EACH columns AS col=>ind BEGIN
				SPRINT data "%data%%col%%TAB%"
			END
			SPRINT data "%data%%WNL%"
		END
		PHP_EACH rows AS row=>discard1 BEGIN
			PHP_EACH columns AS col=>discard2 BEGIN
				SPRINT val $"%array%"("%row%" "%col%")
				SPRINT data "%data%%val%%TAB%"
			END
			SPRINT data "%data%%WNL%"
		END
		// write to file
		DELETE_BYTES 0x0 BUFFER_LENGTH
		INSERT_BYTES 0x0 STRING_LENGTH "%data%"
		WRITE_ASCII 0x0 "%data%"	
	END
	DEFAULT
		PATCH_FAIL "2da_write: unknown type %type%"
	END

END

DEFINE_ACTION_FUNCTION "2da_write"
	INT_VAR number_rows=0//boolean
			reflect=0//boolean
	STR_VAR file="" path="" location="" locbase="" 
		type=""//[2da|ids|table_header|table_noheader]
		array=""//array
		default="*"
BEGIN
	LAF sfo_path STR_VAR path location locbase RET path END
	ACTION_IF "%path%" STR_EQ "" BEGIN
		COPY_EXISTING "%file%" override
			LPF 2da_write INT_VAR number_rows reflect STR_VAR array type default END
		BUT_ONLY
	END ELSE BEGIN
		COPY ".../stratagems-inline/blank" "%path%/%file%"
			LPF 2da_write INT_VAR number_rows reflect STR_VAR array type default END
		BUT_ONLY	
	END
END

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_inject_array}
{
Given a 2d array, a column header of that array, and a k=>v array whose keys are row headers in the 2d array, 
inject the array elements into the 2d array, as (k=>v) goes to (k,col,v).

If force_uppercase=1 (default), array_in's keys are uppercased.
}
*/
/////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_inject_array 
	INT_VAR silent=0//boolean
			force_uppercase=1//boolean
	STR_VAR array=""//array
			array_in=""//array
			column=""
			row=""
	RET_ARRAY array
BEGIN
  OUTER_PATCH "" BEGIN
	CLEAR_ARRAY rows
	CLEAR_ARRAY columns
	PATCH_IF "%row%" STR_CMP "" && "%column%" STR_CMP "" BEGIN
		PATCH_WARN "2da_inject_array: both 'row' and 'column' were specified. Using 'row'."
		SPRINT column ""
	END
	PATCH_IF "%column%" STR_CMP "" BEGIN
		TO_UPPER column
		LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
		PATCH_IF force_uppercase BEGIN
			LPF array_map STR_VAR array=array_in keymap=toupper RET_ARRAY array_in=array END
		END
		LPF array_contains STR_VAR array=columns key="%column%" RET value END
		PATCH_IF !value BEGIN
			PATCH_IF !silent BEGIN
				PATCH_WARN "2da_inject_array: column %column% is absent from 2d array %array%"
			END
		END ELSE BEGIN
			PHP_EACH rows AS this_row=>discard BEGIN
				PHP_EACH columns AS col=>discard BEGIN
					PATCH_IF VARIABLE_IS_SET $"%array_in%"("%this_row%") && "%col%" STR_EQ "%column%" BEGIN
						SPRINT $array("%this_row%" "%col%") $"%array_in%"("%this_row%")
					END ELSE BEGIN
						SPRINT $array("%this_row%" "%col%") $"%array%"("%this_row%" "%col%")
					END
				END 
			END
		END
	END ELSE
	PATCH_IF "%row%" STR_CMP "" BEGIN
		TO_UPPER row
		LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
		PATCH_IF force_uppercase BEGIN
			LPF array_map STR_VAR array=array_in keymap=toupper RET_ARRAY array_in=array END
		END
		LPF array_contains STR_VAR array=rows key="%row%" RET value END
		PATCH_IF !value BEGIN
			PATCH_IF !silent BEGIN
				PATCH_WARN "2da_inject_array: row %row% is absent from 2d array %array%"
			END
		END ELSE BEGIN
			PHP_EACH columns AS col=>discard BEGIN
				PHP_EACH rows AS this_row=>discard BEGIN
					PATCH_IF VARIABLE_IS_SET $"%array_in%"("%col%") && "%this_row%" STR_EQ "%row%" BEGIN
						SPRINT $array("%this_row%" "%col%") $"%array_in%"("%col%")
					END ELSE BEGIN
						SPRINT $array("%this_row%" "%col%") $"%array%"("%this_row%" "%col%")
					END
				END 
			END
		END	
	END ELSE BEGIN
		PATCH_WARN "2da_inject_array: neither 'row' nor 'column' was specified"
	END
  END
END



//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_extract_array}
{Given a 2d array, and column labels 'domain' and 'range' for that array, return a 1d
array whose keys are the elements of the 'domain' column and whose values are the elements
of the 'range' column.

If you leave either 'domain' or 'range' empty, the row headers are used instead. If we can't
find domain or range, we return an empty array (and whine unless silent=1).

Optionally, you can specify functions 'keymap' and/or 'map', which are applied to the keys
and values respectively before being put into the output array. You can use the anonymous
function construct.
}
*/
/////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_extract_array
	INT_VAR silent=0//boolean
	STR_VAR domain=""
			range=""
			array=""//array
			keymap=""//function
			map=""//function
			case=""//[upper|lower|mixed]
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
		// anonymous function construct
		LPF anon_check INT_VAR has_output=1 STR_VAR function="%map%" RET map=function END
		LPF anon_check INT_VAR has_output=1 STR_VAR function="%keymap%" RET keymap=function END
		
		CLEAR_ARRAY lookup_array
		PATCH_IF ("%domain%" STR_EQ "%range%") && !silent BEGIN
			PATCH_WARN "warning: domain and range coincide in 2da_extract_array"
		END
		CLEAR_ARRAY rows
		CLEAR_ARRAY columns
		PATCH_MATCH "%case%" WITH
		lower BEGIN
			TO_LOWER domain
			TO_LOWER range
		END
		upper BEGIN
			TO_UPPER domain
			TO_UPPER range
		END	
		DEFAULT
		END
		LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
		LPF array_contains STR_VAR array=columns key="%domain%" RET found_domain=value END
		LPF array_contains STR_VAR array=columns key="%range%" RET found_range=value END
		PATCH_IF "%domain%" STR_EQ "" && found_range BEGIN // we're using the column entries as lookup
			PHP_EACH rows AS row=>discard BEGIN
				SPRINT v $"%array%"("%row%" "%range%")
				PATCH_IF !("%v%" STR_EQ "*") BEGIN
					PATCH_IF !"%map%" STR_EQ "" BEGIN
						LPF "%map%" STR_VAR arguments="%v%" RET v=value END
					END
					SPRINT $lookup_array("%row%") "%v%"
					found_range=1
				END			
			END	
		END ELSE 
		PATCH_IF "%range%" STR_EQ "" && found_domain BEGIN
			PHP_EACH rows AS row=>discard BEGIN
				SPRINT k $"%array%"("%row%" "%domain%")
				PATCH_IF !("%k%" STR_EQ "*") BEGIN
					PATCH_IF !"%keymap%" STR_EQ "" BEGIN
						LPF "%keymap%" STR_VAR arguments="%k%" RET k=value END
					END
					SPRINT $lookup_array("%k%") "%row%"
					found_domain=1
				END			
			END	
		END ELSE
		PATCH_IF found_domain && found_range BEGIN
			SPRINT row_label ""
			SPRINT d "*"
			SPRINT r "*"
			PHP_EACH rows AS row=>discard BEGIN
				SPRINT d $"%array%"("%row%" "%domain%")
				SPRINT r $"%array%"("%row%" "%range%")
				PATCH_IF "%d%" STR_CMP "*" && "%r%" STR_CMP "*" BEGIN
					PATCH_IF !"%map%" STR_EQ "" BEGIN
							LPF "%map%" STR_VAR arguments="%r%" RET r=value END
					END
					PATCH_IF !"%keymap%" STR_EQ "" BEGIN
						LPF "%keymap%" STR_VAR arguments="%d%" RET d=value END
					END
					SPRINT $lookup_array("%d%") "%r%"
				END
			END		
		END ELSE BEGIN
			PATCH_IF !found_domain && !silent BEGIN
				PATCH_WARN "warning: domain %domain% in 2da_lookup apparently does not exist. Returning empty array."
			END
			PATCH_IF !found_range && !silent BEGIN
				PATCH_WARN "warning: range %range% in 2da_lookup apparently does not exist. Returning empty array."
			END
		END
		CLEAR_ARRAY array
		PHP_EACH lookup_array AS k=>v BEGIN
			SPRINT $array("%k%") "%v%"
		END
	END
END

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_delete_column}
{Given a 2d array, and column label 'column', delete that column.
}
*/
////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_delete_column
	STR_VAR array=""//array
			column=""
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
	CLEAR_ARRAY SFO_2da_delete_column_working_array // we need a guaranteed unique array
	PATCH_IF "%array%" STR_EQ "" BEGIN
		PATCH_WARN "no array specified in 2da_delete_column (trying to delete column %column%)"
	END
	CLEAR_ARRAY rows
	CLEAR_ARRAY columns
	LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
	PHP_EACH "%array%" AS k=>v BEGIN
		PATCH_IF !("%k_1%" STR_EQ "%column%") BEGIN
			SPRINT $SFO_2da_delete_column_working_array("%k_0%" "%k_1%") "%v%"
		END
	END
	CLEAR_ARRAY array
	PHP_EACH SFO_2da_delete_column_working_array AS k=>v BEGIN
		SPRINT $array("%k_0%" "%k_1%") "%v%"
	END
	END
END
			
//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_delete_row}
{Given a 2d array, and row label 'row', delete that row.
}
*/
////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_delete_row
	STR_VAR array=""//array
			row=""
			lookup_column=""
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
	CLEAR_ARRAY SFO_2da_delete_row_working_array // we need a guaranteed unique array
	PATCH_IF "%array%" STR_EQ "" BEGIN
		PATCH_WARN "no array specified in 2da_delete_row (trying to delete row %row%)"
	END
	CLEAR_ARRAY rows
	CLEAR_ARRAY columns
	PATCH_IF "%lookup_column%" STR_EQ "" BEGIN
	LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
		PHP_EACH "%array%" AS k=>v BEGIN
			PATCH_IF !("%k_0%" STR_EQ "%row%") BEGIN
				SPRINT $SFO_2da_delete_row_working_array("%k_0%" "%k_1%") "%v%"
			END
		END
	END ELSE BEGIN	
		SPRINT row_header ""
		PHP_EACH "%array%" AS k=>v BEGIN
			PATCH_IF !("%k_0%" STR_EQ "%row_header%") BEGIN // new row
				SPRINT row_header "%k_0%"
				delete_this_row="%row%" STR_EQ $"%array%"("%k_0%" "%lookup_column%")
			END
			PATCH_IF !delete_this_row BEGIN
				SPRINT $SFO_2da_delete_row_working_array("%k_0%" "%k_1%") "%v%"
			END
		END	
	END
	CLEAR_ARRAY array
	PHP_EACH SFO_2da_delete_row_working_array AS k=>v BEGIN
		SPRINT $array("%k_0%" "%k_1%") "%v%"
	END
	END
END
		
//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_renumber}
{
Given a 2d array, replace its row labels with sequential integers starting at 'start_at' (i.e. 0 by default)
}
*/
////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_renumber
	INT_VAR start_at=0
	STR_VAR array=""//array
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
	CLEAR_ARRAY SFO_2da_renumber_working_array // we need a guaranteed unique array
	PATCH_IF "%array%" STR_EQ "" BEGIN
		PATCH_WARN "no array specified in 2da_renumber"
	END
	row=start_at - 1
	SPRINT row_header ""
	PHP_EACH "%array%" AS k=>v BEGIN
		PATCH_IF !("%k_0%" STR_EQ "%row_header%") BEGIN // new row
			++row
			SPRINT row_header "%k_0%"
		END
		SPRINT $SFO_2da_renumber_working_array("%row%" "%k_1%") "%v%"
	END
	CLEAR_ARRAY array
	PHP_EACH SFO_2da_renumber_working_array AS k=>v BEGIN
		SPRINT $array("%k_0%" "%k_1%") "%v%"
	END
	END
END		

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_insert_row}
{
Given a 2d array, and a row label, insert a new row with that row label in the position specified by
'location'. 'location' can be 'first' (or 'start'), 'last' (or 'end'), 'before row_label' or 'after row_label'.
If we can't find the row label, we default to 'last' (and whine about it unless silent=1).

The new rows are filled with 'entry'.
}
*/
////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_insert_row
	INT_VAR silent=0//boolean
	STR_VAR array=""//array
			row=""
			location=""
			entry="-1"
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
	CLEAR_ARRAY SFO_2da_working_array // we need a guaranteed unique array
	PATCH_IF "%array%" STR_EQ "" BEGIN
		PATCH_WARN "no array specified in 2da_insert_row"
	END
	// add it to the 'rows' array
	LPF array_keys STR_VAR array RET_ARRAY rows_in=keys1 columns=keys2 END
	CLEAR_ARRAY rows
	PATCH_MATCH "%location%" WITH
	last end BEGIN
		warn=0
		PHP_EACH rows_in AS k=>discard BEGIN
			SPRINT $rows("%k%") ""
		END
		SPRINT $rows("%row%") ""
	END
	first start BEGIN
		warn=0
		SPRINT $rows("%row%") ""	
		PHP_EACH rows_in AS k=>discard BEGIN
			SPRINT $rows("%k%") ""
		END
	END
	"before .*" BEGIN
		warn=1
		INNER_PATCH_SAVE match_row "%location%" BEGIN
			REPLACE_TEXTUALLY "before " ""
		END
		PHP_EACH rows_in AS k=>discard BEGIN
			PATCH_IF "%k%" STR_EQ "%match_row%" BEGIN
				SPRINT $rows("%row%") ""
				warn=0
			END
			SPRINT $rows("%k%") ""
		END
	END
	"after .*" BEGIN
		warn=1
		INNER_PATCH_SAVE match_row "%location%" BEGIN
			REPLACE_TEXTUALLY "after " ""
		END
		PHP_EACH rows_in AS k=>discard BEGIN
			SPRINT $rows("%k%") ""
			PATCH_IF "%k%" STR_EQ "%match_row%" BEGIN
				SPRINT $rows("%row%") ""
				warn=0
			END
		END
	END
	DEFAULT
		PATCH_WARN "'%location%' is not a legal location for 2da_insert_row. Legal locations are 'before ROW', 'after ROW', 'first' (or 'start'), and 'last' (or 'end')"
		PHP_EACH rows_in AS k=>discard BEGIN
			SPRINT $rows("%k%") ""
		END
	END
	// put it at the end if you can't find a match
	PATCH_IF warn BEGIN
		PATCH_IF !silent BEGIN 
			PATCH_WARN "Failed to find row '%match_row%' in 2da_insert_row; putting it at the end instead"
		END
		PHP_EACH rows_in AS k=>discard BEGIN
			SPRINT $rows("%k%") ""
		END
		SPRINT $rows("%row%") ""
	END
	// write the main array
	PHP_EACH rows AS this_row=>discard BEGIN
		PHP_EACH columns AS this_col=>discard2 BEGIN
			PATCH_IF "%this_row%" STR_EQ "%row%" BEGIN
				SPRINT $SFO_2da_working_array("%this_row%" "%this_col%") "%entry%" 
			END ELSE BEGIN
				SPRINT $SFO_2da_working_array("%this_row%" "%this_col%") $"%array%"("%this_row%" "%this_col%")
			END		
		END	
	END
	// flush it into output
	CLEAR_ARRAY array
	PHP_EACH SFO_2da_working_array AS k=>v BEGIN
		SPRINT $array("%k_0%" "%k_1%") "%v%"
	END
	END
	
END		

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_insert_column}
{
Given a 2d array, and a column label, insert a new column with that column label in the position specified by
'location'. 'location' can be 'first' (or 'start'), 'last' (or 'end'), 'before column_label' or 'after column_label'.
If we can't find the column label, we default to 'last' (and whine about it unless silent=1).

The new rows are filled with 'entry'.
}
*/
//////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_insert_column
	INT_VAR silent=0//boolean
	STR_VAR array=""//array
			column=""
			location=""
			entry="-1"
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
	CLEAR_ARRAY SFO_2da_working_array // we need a guaranteed unique array
	PATCH_IF "%array%" STR_EQ "" BEGIN
		PATCH_WARN "no array specified in 2da_insert_column"
	END
	// add it to the 'columns' array
	LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns_in=keys2 END
	CLEAR_ARRAY columns
	PATCH_MATCH "%location%" WITH
	last end BEGIN
		warn=0
		PHP_EACH columns_in AS k=>discard BEGIN
			SPRINT $columns("%k%") ""
		END
		SPRINT $columns("%column%") ""
	END
	first start BEGIN
		warn=0
		SPRINT $columns("%column%") ""	
		PHP_EACH columns_in AS k=>discard BEGIN
			SPRINT $columns("%k%") ""
		END
	END
	"before .*" BEGIN
		warn=1
		INNER_PATCH_SAVE match_col "%location%" BEGIN
			REPLACE_TEXTUALLY "before " ""
		END
		PHP_EACH columns_in AS k=>discard BEGIN
			PATCH_IF "%k%" STR_EQ "%match_col%" BEGIN
				SPRINT $columns("%column%") ""
				warn=0
			END
			SPRINT $columns("%k%") ""
		END
	END
	"after .*" BEGIN
		warn=1
		INNER_PATCH_SAVE match_col "%location%" BEGIN
			REPLACE_TEXTUALLY "after " ""
		END
		PHP_EACH columns_in AS k=>discard BEGIN
			SPRINT $columns("%k%") ""
			PATCH_IF "%k%" STR_EQ "%match_col%" BEGIN
				SPRINT $columns("%column%") ""
				warn=0
			END
		END
	END
	DEFAULT
		PATCH_WARN "'%location%' is not a legal location for 2da_insert_column. Legal locations are 'before COLUMN', 'after COLUMN', 'first' (or 'start'), and 'last' (or 'end')"
		PHP_EACH columns_in AS k=>discard BEGIN
			SPRINT $columns("%k%") ""
		END
	END
	// put it at the end if you can't find a match
	PATCH_IF warn BEGIN
		PATCH_IF !silent BEGIN 
			PATCH_WARN "Failed to find column '%match_col%' in 2da_insert_column; putting it at the end instead"
		END
		PHP_EACH columns_in AS k=>discard BEGIN
			SPRINT $columns("%k%") ""
		END
		SPRINT $columns("%column%") ""
	END
	// write the main array
	PHP_EACH rows AS this_row=>discard BEGIN
		PHP_EACH columns AS this_col=>discard2 BEGIN
			PATCH_IF "%this_col%" STR_EQ "%column%" BEGIN
				SPRINT $SFO_2da_working_array("%this_row%" "%this_col%") "%entry%" 
			END ELSE BEGIN
				SPRINT $SFO_2da_working_array("%this_row%" "%this_col%") $"%array%"("%this_row%" "%this_col%")
			END		
		END	
	END
	// flush it into output
	CLEAR_ARRAY array
	PHP_EACH SFO_2da_working_array AS k=>v BEGIN
		SPRINT $array("%k_0%" "%k_1%") "%v%"
	END
	END
END		


//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_clone_row}
{
Given a 2d array, a row label 'clone_from', and a new row label 'clone_to', insert a copy of the clone_from
row with the clone_to label, in the position specified by
'location'. 'location' can be 'first' (or 'start'), 'last' (or 'end'), 'before row_label' or 'after row_label'.
If we can't find the row label, we default to 'last' (and whine about it unless silent=1).
}
*/
//////////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION 2da_clone_row
	INT_VAR silent=0//boolean
	STR_VAR array=""//array
			clone_to=""
			location=""
			clone_from=""
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
	PATCH_IF "%array%" STR_EQ "" BEGIN
		PATCH_WARN "no array specified in 2da_clone_row"
	END
	// create a blank row
	LPF 2da_insert_row INT_VAR silent STR_VAR array row="%clone_to%" location RET_ARRAY array END
	// get the columns
	LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
	// clone the data
	PATCH_IF !"%array%" STR_EQ "array" BEGIN 
		CLEAR_ARRAY array
		PHP_EACH "%array%" AS k=>v BEGIN
			SPRINT $array("%k_0%" "%k_1%") "%v%"
		END	
	END
	warn=1
	PHP_EACH columns AS col=>discard BEGIN
		PATCH_IF VARIABLE_IS_SET $"%array%"("%clone_from%" "%col%") BEGIN
			SPRINT $array("%clone_to%" "%col%") $"%array%"("%clone_from%" "%col%")
			warn=0
		END
	END
	PATCH_IF (warn && !silent) BEGIN
		PATCH_WARN "row %clone_from% does not exist, so can't be cloned; new row will be blank"
	END
	END
END		

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_clone_column}
{
Given a 2d array, a column label 'clone_from', and a new column label 'clone_to', insert a copy of the clone_from
column with the clone_to label, in the position specified by
'location'. 'location' can be 'first' (or 'start'), 'last' (or 'end'), 'before column_label' or 'after column_label'.
If we can't find the column label, we default to 'last' (and whine about it unless silent=1).
}
*/
//////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_clone_column
	INT_VAR silent=0//boolean
	STR_VAR array=""//array
			clone_to=""
			location=""
			clone_from=""
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
	PATCH_IF "%array%" STR_EQ "" BEGIN
		PATCH_WARN "no array specified in 2da_clone_column"
	END
	// create a blank row
	LPF 2da_insert_column INT_VAR silent STR_VAR array column="%clone_to%" location RET_ARRAY array END
	// get the columns
	LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
	// clone the data
	PATCH_IF !"%array%" STR_EQ "array" BEGIN 
		CLEAR_ARRAY array
		PHP_EACH "%array%" AS k=>v BEGIN
			SPRINT $array("%k_0%" "%k_1%") "%v%"
		END	
	END
	warn=1
	PHP_EACH rows AS row=>discard BEGIN
		PATCH_IF VARIABLE_IS_SET $"%array%"("%row%" "%clone_from%") BEGIN
			SPRINT $array("%row%" "%clone_to%") $"%array%"("%row%" "%clone_from%")
			warn=0
		END
	END
	PATCH_IF (warn && !silent) BEGIN
		PATCH_WARN "column %clone_from% does not exist, so can't be cloned; new column will be blank"
	END
	END
END		

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_column_to_array}
{
Given a 2d array and column label 'column', extract that column as a 1d array indexed by the 
row labels. 

If we can't find the column label, we return an empty array (and whine about it unless silent=1).
}
*/
//////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_column_to_array
	INT_VAR silent=0//boolean
	STR_VAR column="" 
			array=""//array
	RET_ARRAY array_out
BEGIN
  OUTER_PATCH "" BEGIN
	CLEAR_ARRAY array_out
	found=0
	PHP_EACH "%array%" AS k=>v BEGIN
		PATCH_IF "%k_1%" STR_EQ "%column%" BEGIN
			found=1
			SPRINT $array_out("%k_0%") "%v%"
		END
	END
	PATCH_IF !(found || silent) BEGIN
		PATCH_WARN "Column %column% not found in 2da %array%; returning empty array"
	END
  END
END

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_row_to_array}
{
Given a 2d array and row label 'row', extract that row as a 1d array indexed by the 
column labels. 

If we can't find the row label, we return an empty array (and whine about it unless silent=1).
}
*/
//////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_row_to_array
	INT_VAR silent=0//boolean
	STR_VAR row="" 
			array=""//array
	RET_ARRAY array_out
BEGIN
  OUTER_PATCH "" BEGIN
	CLEAR_ARRAY array_out
	found=0
	PHP_EACH "%array%" AS k=>v BEGIN
		PATCH_IF "%k_0%" STR_EQ "%row%" BEGIN
			found=1
			SPRINT $array_out("%k_1%") "%v%"
		END
	END
	PATCH_IF !(found || silent) BEGIN
		PATCH_WARN "Row %row% not found in 2da %array%; returning empty array"
	END
  END
END


//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_to_3da}
{
Given a 2d array and two column headers, extract a 3d array where the first two keys are the
values in the new columns and the third is the old column header.

e.g. if row 14 has col1=x, col2=y, then 3da(x,y,z)=2da(14,z).
}
*/
//////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////
/// 2da to 3da - we ignore the row labels, and use 2 columns to construct the new labels
////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_to_3da 
	STR_VAR column1=""
			column2=""
			array=""//array
	RET_ARRAY array_out
BEGIN
	OUTER_PATCH "" BEGIN
		CLEAR_ARRAY array_out
	LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
		PHP_EACH rows AS row=>discard BEGIN
			SPRINT k1 $"%array%"("%row%" "%column1%")
			SPRINT k2 $"%array%"("%row%" "%column2%")
			PHP_EACH columns AS column=>discard2 BEGIN
				PATCH_MATCH "%column%" WITH 
				"%column1%" "%column2%" BEGIN
				END
				DEFAULT
					SPRINT $array_out("%k1%" "%k2%" "%column%") $"%array%"("%row%" "%column%")
				END			
			END	
		END
	END
END


//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_make}
{
Given two arrays in k=>_ format, make a 2da with each character filled with some fixed data
}
*/
//////////////////////////////////////////////////////////////////////////////////////



DEFINE_DIMORPHIC_FUNCTION 2da_make
	STR_VAR rows=""//array
			columns=""//array
			fill="*"
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
		CLEAR_ARRAY array
		PHP_EACH "%rows%" AS row=>discard BEGIN
			PHP_EACH "%columns%" AS col=>discard2 BEGIN
				SPRINT $array("%row%" "%col%") "%fill%"
			END
		END
	END
END

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_process_table}
{
'table' should be a header table whose headers are the arguments of the action function 'function'.
(INT_VAR arguments should be indicated with ':i'.) Each row of the table is fed to the function.

Alternately, if INT_VAR 2da is set to 1, 'table' can be a 2da. It is treated the same way, except
that each row name is fed to the function as the STR_VAR 'rowname'

}
*/
//////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION 2da_process_table
	INT_VAR inline=0
			2da=0
	STR_VAR table=""
			path=""
			location=""
			locbase=""
			function=""
BEGIN
	// get the data
	ACTION_IF 2da BEGIN
		LAF 2da_read INT_VAR inline STR_VAR file="%table%" path location locbase type=2da case=mixed RET_ARRAY rows columns array END	
	END ELSE BEGIN
		LAF 2da_read INT_VAR inline STR_VAR file="%table%" path location locbase type=table_header case=mixed RET_ARRAY rows columns array END
	END
	// get the STR and INT variables
	ACTION_CLEAR_ARRAY ints
	ACTION_CLEAR_ARRAY strs
	OUTER_SPRINT int_string ""
	OUTER_SPRINT str_string ""
	ACTION_PHP_EACH columns AS arg=>discard BEGIN
		OUTER_SET is_int=0
		OUTER_PATCH_SAVE arg "%arg%" BEGIN
			REPLACE_EVALUATE "\(.*\):i" BEGIN
				is_int=1
			END
			"%MATCH1%"
		END
		ACTION_IF is_int BEGIN
			OUTER_SPRINT $ints("%arg%") ""
			OUTER_SPRINT int_string "%int_string%%arg% "
		END ELSE BEGIN
			OUTER_SPRINT $strs("%arg%") ""
			OUTER_SPRINT str_string "%str_string%%arg% "
		END
	END
	ACTION_IF 2da BEGIN
		OUTER_SPRINT str_string "%str_string%rowname "
	END
	// make the function call
	COPY ".../stratagems-inline/process_table_include.tpc" "%workspace%" EVALUATE_BUFFER 
	// do the rows
	ACTION_PHP_EACH rows AS row=>discard BEGIN
		ACTION_PHP_EACH ints AS int=>discard2 BEGIN
			OUTER_SET "%int%"=$array("%row%" "%int%:i")
		END
		ACTION_PHP_EACH strs AS str=>discard2 BEGIN
			OUTER_SPRINT "%str%" $array("%row%" "%str%")
		END	
		ACTION_IF 2da BEGIN
			OUTER_SPRINT rowname "%row%"
		END
		REINCLUDE "%workspace%/process_table_include.tpc"
	END
END	

<<<<<<<<.../stratagems-inline/process_table_include.tpc
LAF %function% INT_VAR %int_string% STR_VAR %str_string% END
>>>>>>>>

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_sort}
{
Takes a 2da, sorts rows and/or columns.
Set "rows" and/or "columns" to "lexicographically" or "numerically" (case-insensitive). Can use 'l' or 'n' as synonyms

}
*/
//////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_sort 
	STR_VAR rows=""
			columns=""
			array=""
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
		LPF array_keys STR_VAR array="%array%" RET_ARRAY array_rows=keys1 array_columns=keys2 END
		done_anything=0
		PATCH_MATCH "%rows%" WITH
		"lexicographically" "l" BEGIN
			done_anything=1
			SORT_ARRAY_INDICES array_rows LEXICOGRAPHICALLY
		END
		"numerically" "l" BEGIN
			done_anything=1
			SORT_ARRAY_INDICES array_rows NUMERICALLY
		END
		"" BEGIN
		END
		DEFAULT
			done_anything=1
			PATCH_WARN "2da_sort: illegal argument %rows%"
		END
		PATCH_MATCH "%columns%" WITH
		"lexicographically" "l" BEGIN
			done_anything=1
			SORT_ARRAY_INDICES array_rows LEXICOGRAPHICALLY
		END
		"numerically" "l" BEGIN
			done_anything=1
			SORT_ARRAY_INDICES array_rows NUMERICALLY
		END
		"" BEGIN
		END
		DEFAULT
			done_anything=1
			PATCH_WARN "2da_sort: illegal argument %columns%"
		END
		PATCH_IF !done_anything BEGIN
			PATCH_WARN "2da_sort called with no actual arguments"
		END
		CLEAR_ARRAY sfo_working_array // 'array' might be set to 'array'
		PHP_EACH array_rows AS row=>discard BEGIN
			PHP_EACH array_columns AS column=>discard BEGIN
				SPRINT $sfo_working_array("%row%" "%column%") $"%array%"("%row%" "%column%")
			END
		END
		CLEAR_ARRAY array
		PHP_EACH array_rows AS row=>discard BEGIN
			PHP_EACH array_columns AS column=>discard BEGIN
				SPRINT $array("%row%" "%column%") $sfo_working_array("%row%" "%column%")
			END
		END
	END
END
	
//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_find_default}
{
In the current file, return the default 2da entry, or "NOT_2DA" if the file is not a 2da file.


}
*/
//////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION 2da_find_default RET value
BEGIN
	SPRINT value "NOT_2DA"
	PATCH_IF INDEX_BUFFER ("2DA[ %TAB%]+V1\.0")=0 BEGIN
		READ_2DA_ENTRY 1 0 1 value
		
	END




END

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_prettier_print}
{
Like PRETTY_PRINT_2DA, but checks the file has >2 rows and doesn't treat "2DA V1.0" as two columns


}
*/
//////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION 2da_prettier_print 
BEGIN
		COUNT_2DA_ROWS 0 rowcount
		PATCH_IF rowcount>2 BEGIN
			PRETTY_PRINT_2DA
			REPLACE_TEXTUALLY "^2DA[ %TAB%]+V1.0" "2DA V1.0"
		END
END

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_fix}
{
Turns the current file (assumed to be a 2da file) into a legal 2da file with no incomplete entries, by
<ol>
<li>forcing the first line to be '2DA V1.0'</li>
<li>removing any entry beyond the first on the second line</li>
<li>truncating any entries that lie beyond the range defined by the columns on the third line</li>
<li>filling in any incomplete entries with the array's default character.</li>
</ol>
Returns 'legal', which is 1 or 0, and 'fixed_file', which is just a 
string containing the full contents of the file. Optional argument: 'apply_to_file' 
(can be 1 or 0, default is 1); if set to 1, the changes are actually carried out on the file being patched; if set to 0, they're discarded

}
*/
//////////////////////////////////////////////////////////////////////////////////////




DEFINE_PATCH_FUNCTION 2da_fix
	INT_VAR apply_to_file=1//boolean
	RET legal
		fixed_file
BEGIN
	COUNT_2DA_COLS colcount
	COUNT_2DA_ROWS 1 rowcount_one
	COUNT_2DA_ROWS 2 rowcount_two
	COUNT_2DA_ROWS colcount rowcount_max
	COUNT_2DA_ROWS (colcount - 1) rowcount_max_minus_one
	PATCH_IF rowcount_one>=4 BEGIN
	PATCH_MATCH colcount WITH
	1 BEGIN // no salvageable 2da file has colcount=1
		PATCH_FAIL "2da_sanity_check: current file (probably %SOURCE_FILE%) is unfixable"
	END
	2 BEGIN // all rows should have 2 columns except the default and the column labels
		legal = (rowcount_one = rowcount_two + 2)
	END
	3 BEGIN // there should be one 1-column row (the default), two 2-column rows (the sig and the column labels) and the rest 3-column
		legal = (rowcount_one = rowcount_max + 3) && (rowcount_two = rowcount_max + 2)
	END
	DEFAULT // there should be one 1-column row, 1 2-column row, 1 (N-1)-column row, and the rest N columns
		legal = (rowcount_one = rowcount_max + 3) && (rowcount_two = rowcount_max +2) && (rowcount_max_minus_one = rowcount_max + 1)
	END
	END ELSE BEGIN
		legal=1  // we can't fix problems in empty 2DAs
	END
	PATCH_IF legal BEGIN
		READ_ASCII 0x0 fixed_file (BUFFER_LENGTH)
	END ELSE BEGIN
		// get the contents
		READ_ASCII 0x0 data (BUFFER_LENGTH)
		// break into lines
		INNER_PATCH "%data%" BEGIN
			CLEAR_ARRAY lines
			count=0
			REPLACE_EVALUATE "^\([^%WNL%%MNL%%LNL%]+\)" BEGIN
				SPRINT $lines("%count%") "%MATCH1%"
				++count
			END	
			""
		END
		// fix first lines if necessary
		SPRINT line0 $lines(0)
		SPRINT line1 $lines(1)
		PATCH_MATCH "%line0%" WITH
		"2DA[ %TAB%]+V1.0" BEGIN // line 0 basically okay
			SPRINT $lines(0) "2DA V1.0"
			PATCH_MATCH "%line1%" WITH
			"[^ %TAB%]+" BEGIN // line 1 also okay
				SPRINT extra_start ""
				column_line_num=2
				SPRINT default_entry "%line1%"
			END
			DEFAULT // more than one character on line 1, so assume it's the column row
				SPRINT extra_start "*%WNL%"
				column_line_num=1	
				SPRINT default_entry "*"
			END
		END
		"[^ %TAB%]+" BEGIN //line 0 has one character, so assume it's the default and that the sig is missing
			SPRINT extra_start "2DA V1.0%WNL%"
			SPRINT default_entry "%line0%"
			column_line_num=1
		END
		DEFAULT // line 0 has 2+characters, so assume both default and sig are missing and we start straight away with cols
			SPRINT extra_start "2DA V1.0%WNL%*%WNL%"
			SPRINT default_entry "*"
			column_line_num=0
		END
		// get the column count
		SPRINT column_line $lines("%column_line_num%")
		INNER_PATCH " %column_line%" BEGIN // extra space just in case
			count=0
			REPLACE_EVALUATE "[ %TAB%]+[^ %TAB%]+" BEGIN
				++count
			END
			""
		END
		real_colcount=count
		// fix the remaining lines
		PHP_EACH lines AS line_num=>line BEGIN
			PATCH_IF line_num>column_line_num BEGIN
				SPRINT line_new ""
				INNER_PATCH " %line%" BEGIN // extra space just in case
					count=0
					REPLACE_EVALUATE "[ %TAB%]+\([^ %TAB%]+\)" BEGIN
						PATCH_IF count<=real_colcount BEGIN
							SPRINT line_new "%line_new%%MATCH1% "
						END
						++count						
					END
					""
				END		
				FOR (n=count;n<=real_colcount;++n) BEGIN
					SPRINT line_new "%line_new%%default_entry% "
				END
				SPRINT $lines("%line_num%") "%line_new%"
			END
		END
		// make the file
		SPRINT fixed_file "%extra_start%"
		PHP_EACH lines AS line_num=>line BEGIN
			SPRINT fixed_file "%fixed_file%%line%%WNL%"
		END
		// apply fix if required
		PATCH_IF apply_to_file BEGIN
			DELETE_BYTES 0x0 BUFFER_LENGTH
			INSERT_BYTES 0x0 STRING_LENGTH "%fixed_file%"
			WRITE_ASCII 0x0 "%fixed_file%"
			PRETTY_PRINT_2DA
			REPLACE_TEXTUALLY "2DA[ %TAB%]+V1\.0" "2DA V1.0"
		END
	END
END
